-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Dependent sum type
--   
--   A dependent sum is a generalization of a particular way of thinking
--   about the <tt>Either</tt> type. <tt>Either a b</tt> can be thought of
--   as a 2-tuple <tt>(tag, value)</tt>, where the value of the tag
--   determines the type of the value. In particular, either <tt>tag =
--   Left</tt> and <tt>value :: a</tt> or <tt>tag = Right</tt> and
--   <tt>value :: b</tt>.
--   
--   This package allows you to define your own dependent sum types by
--   using your own "tag" types.
@package dependent-sum
@version 0.7.1.0

module Data.Dependent.Sum

-- | A basic dependent sum type where the first component is a tag that
--   specifies the type of the second. For example, think of a GADT such
--   as:
--   
--   <pre>
--   data Tag a where
--      AString :: Tag String
--      AnInt   :: Tag Int
--      Rec     :: Tag (DSum Tag Identity)
--   </pre>
--   
--   Then we can write expressions where the RHS of
--   <tt>(<a>:=&gt;</a>)</tt> has different types depending on the
--   <tt>Tag</tt> constructor used. Here are some expressions of type
--   <tt>DSum Tag <tt>Identity</tt></tt>:
--   
--   <pre>
--   AString :=&gt; Identity "hello!"
--   AnInt   :=&gt; Identity 42
--   </pre>
--   
--   Often, the <tt>f</tt> we choose has an <a>Applicative</a> instance,
--   and we can use the helper function <tt>(<a>==&gt;</a>)</tt>. The
--   following expressions all have the type <tt>Applicative f =&gt; DSum
--   Tag f</tt>:
--   
--   <pre>
--   AString ==&gt; "hello!"
--   AnInt   ==&gt; 42
--   </pre>
--   
--   We can write functions that consume <tt>DSum Tag f</tt> values by
--   matching, such as:
--   
--   <pre>
--   toString :: DSum Tag Identity -&gt; String
--   toString (AString :=&gt; Identity str) = str
--   toString (AnInt   :=&gt; Identity int) = show int
--   toString (Rec     :=&gt; Identity sum) = toString sum
--   </pre>
--   
--   The <tt>(<a>:=&gt;</a>)</tt> constructor and <tt>(<a>==&gt;</a>)</tt>
--   helper are chosen to resemble the <tt>(key =&gt; value)</tt>
--   construction for dictionary entries in many dynamic languages. The
--   <tt>:=&gt;</tt> and <tt>==&gt;</tt> operators have very low precedence
--   and bind to the right, making repeated use of these operators behave
--   as you'd expect:
--   
--   <pre>
--   -- Parses as: Rec ==&gt; (AnInt ==&gt; (3 + 4))
--   -- Has type: Applicative f =&gt; DSum Tag f
--   Rec ==&gt; AnInt ==&gt; 3 + 4
--   </pre>
--   
--   The precedence of these operators is just above that of <a>$</a>, so
--   <tt>foo bar $ AString ==&gt; "eep"</tt> is equivalent to <tt>foo bar
--   (AString ==&gt; "eep")</tt>.
--   
--   To use the <a>Eq</a>, <a>Ord</a>, <a>Read</a>, and <a>Show</a>
--   instances for <tt><a>DSum</a> tag f</tt>, you will need an
--   <a>ArgDict</a> instance for your tag type. Use <a>deriveArgDict</a>
--   from the <tt>constraints-extras</tt> package to generate this
--   instance.
data DSum tag f
(:=>) :: !tag a -> f a -> DSum tag f
infixr 1 :=>

-- | Convenience helper. Uses <a>pure</a> to lift <tt>a</tt> into <tt>f
--   a</tt>.
(==>) :: Applicative f => tag a -> a -> DSum tag f
infixr 1 ==>

-- | <i>Deprecated: Instead of 'ShowTag tag f', use '(GShow tag, Has' Show
--   tag f)'</i>
type ShowTag tag f = (GShow tag, Has' Show tag f)
showTaggedPrec :: forall tag f a. (GShow tag, Has' Show tag f) => tag a -> Int -> f a -> ShowS

-- | <i>Deprecated: Instead of 'ReadTag tag f', use '(GRead tag, Has' Read
--   tag f)'</i>
type ReadTag tag f = (GRead tag, Has' Read tag f)
readTaggedPrec :: forall tag f a. (GRead tag, Has' Read tag f) => tag a -> Int -> ReadS (f a)

-- | <i>Deprecated: Instead of 'EqTag tag f', use '(GEq tag, Has' Eq tag
--   f)'</i>
type EqTag tag f = (GEq tag, Has' Eq tag f)
eqTaggedPrec :: forall tag f a. (GEq tag, Has' Eq tag f) => tag a -> tag a -> f a -> f a -> Bool
eqTagged :: forall tag f a. EqTag tag f => tag a -> tag a -> f a -> f a -> Bool

-- | <i>Deprecated: Instead of 'OrdTag tag f', use '(GCompare tag, Has' Eq
--   tag f, Has' Ord tag f)'</i>
type OrdTag tag f = (GCompare tag, Has' Eq tag f, Has' Ord tag f)
compareTaggedPrec :: forall tag f a. (GCompare tag, Has' Eq tag f, Has' Ord tag f) => tag a -> tag a -> f a -> f a -> Ordering
compareTagged :: forall tag f a. OrdTag tag f => tag a -> tag a -> f a -> f a -> Ordering
instance forall k (tag :: k -> *) (f :: k -> *). (Data.GADT.Internal.GShow tag, Data.Constraint.Extras.Has' GHC.Show.Show tag f) => GHC.Show.Show (Data.Dependent.Sum.DSum tag f)
instance forall k (tag :: k -> *) (f :: k -> *). (Data.GADT.Internal.GRead tag, Data.Constraint.Extras.Has' GHC.Read.Read tag f) => GHC.Read.Read (Data.Dependent.Sum.DSum tag f)
instance forall k (tag :: k -> *) (f :: k -> *). (Data.GADT.Internal.GEq tag, Data.Constraint.Extras.Has' GHC.Classes.Eq tag f) => GHC.Classes.Eq (Data.Dependent.Sum.DSum tag f)
instance forall k (tag :: k -> *) (f :: k -> *). (Data.GADT.Internal.GCompare tag, Data.Constraint.Extras.Has' GHC.Classes.Eq tag f, Data.Constraint.Extras.Has' GHC.Classes.Ord tag f) => GHC.Classes.Ord (Data.Dependent.Sum.DSum tag f)
