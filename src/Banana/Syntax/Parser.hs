{-|
Module      : Parser
Description : Parses the tokens into an AST

The parser gets fed the token generated by the lexer and generates an AST
  from them representing the program.
-}
module Banana.Syntax.Parser (
  parseType,
  parseVarDecl,
  parseExpr,
  parseVarAssign,
  parseProgram,
  parseFuncCall
) where

import           Banana.Syntax.AST
import           Control.Applicative
import           Text.Parser.Char
import           Text.Parser.Combinators (eof, try)
import           Text.Parser.Expression
import           Text.Parser.Token
import           Text.Parser.Token.Style
import           Text.Trifecta.Parser

-- | Parse a type
parseType :: Parser Type
parseType = (string "num" >> return Number)
        <|> (string "array" >> do
              space >> whiteSpace
              size <- natural
              whiteSpace
              Array size <$> parseType)

-- | Parse variable declarations
parseVarDecl :: Parser (VarDecl String)
parseVarDecl = do
  string "var" >> space >> whiteSpace
  name <- ident emptyIdents
  whiteSpace >> char ':' >> whiteSpace
  VarDecl name <$> (parseType <* whiteSpace)

-- | Parse a function call
parseFuncCall :: Parser (FuncCall String)
parseFuncCall = FuncCall <$> ident emptyIdents <*> parens (commaSep parseExpr)

-- | Parse an arithmetic expression
parseExpr :: Parser (Expr String)
parseExpr = buildExpressionParser table term

term :: Parser (Expr String)
term = parens parseExpr
   <|> Lit . toDouble <$> integerOrDouble
   <|> try (FuncCallExpr <$> parseFuncCall)
   <|> Var <$> ident emptyIdents
    where
      toDouble (Left i)  = fromInteger i
      toDouble (Right d) = d

table :: [[Operator Parser (Expr a)]]
table = [ [binary "*" Mul AssocLeft, binary "/" Div AssocLeft ]
        , [binary "+" Add AssocLeft, binary "-" Sub AssocLeft ]
        , [ binary "="  Eq   AssocLeft
          , binary "/=" NEq  AssocLeft
          , binary "<"  Less AssocLeft
          , binary ">"  More AssocLeft
          , binary "<=" LEq  AssocLeft
          , binary ">=" MEq  AssocLeft
          ]
        , [prefix "not" Not]
        , [binary "and" And AssocLeft]
        , [binary "or"  Or  AssocLeft]
        ]
-- http://hackage.haskell.org/package/parsers-0.12.10/docs/Text-Parser-Expression.html
binary :: String -> (a -> a -> a) -> Assoc -> Operator Parser a
binary  name fun = Infix (fun <$ reservedOp name)
prefix :: String -> (a -> a) -> Operator Parser a
prefix  name fun = Prefix (fun <$ reservedOp name)
-- postfix :: String -> (a -> a) -> Operator Parser a
-- postfix name fun = Postfix (fun <$ reservedOp name)

reservedOp :: String -> Parser ()
reservedOp = reserve emptyOps

-- | Parse the variable assignment statement
parseVarAssign :: Parser (VarAssign String)
parseVarAssign = do
  var <- parseExpr
  whiteSpace >> string ":=" >> whiteSpace
  VarAssign var <$> (parseExpr <* whiteSpace)

-- | Parse a program consisting of variable declarations and assignments
parseProgram :: Parser (Program String)
parseProgram = do
    do
      var  <- parseVarDecl
      prog <- parseProgram <* whiteSpace
      return prog { statements = VarDeclaration var : statements prog }
  <|>
    try (do
      funcCall <- parseFuncCall
      prog <- parseProgram <* whiteSpace
      return prog { statements = FuncCallStatement funcCall : statements prog })
  <|>
    do
      assign <- parseVarAssign
      prog   <- parseProgram <* whiteSpace
      return prog { statements = VarAssignment assign : statements prog }
  <|>
    do
      whiteSpace >> eof
      return (Program [] [])
