-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroups, specialized containers and a general map/reduce framework
--   
--   Semigroups, specialized containers and a general map/reduce framework.
@package reducers
@version 3.12.3

module Data.Semigroup.Instances


-- | A <tt>c</tt>-<a>Reducer</a> is a <a>Semigroup</a> with a canonical
--   mapping from <tt>c</tt> to the Semigroup.
module Data.Semigroup.Reducer

-- | This type may be best read infix. A <tt>c <a>Reducer</a> m</tt> is a
--   <a>Semigroup</a> <tt>m</tt> that maps values of type <tt>c</tt>
--   through <tt>unit</tt> to values of type <tt>m</tt>. A
--   <tt>c</tt>-<a>Reducer</a> may also supply operations which tack-on
--   another <tt>c</tt> to an existing <a>Monoid</a> <tt>m</tt> on the left
--   or right. These specialized reductions may be more efficient in some
--   scenarios and are used when appropriate by a <tt>Generator</tt>. The
--   names <a>cons</a> and <a>snoc</a> work by analogy to the synonymous
--   operations in the list monoid.
--   
--   This class deliberately avoids functional-dependencies, so that () can
--   be a <tt>c</tt>-Reducer for all <tt>c</tt>, and so many common
--   reducers can work over multiple types, for instance, First and Last
--   may reduce both <tt>a</tt> and <a>Maybe</a> <tt>a</tt>. Since a
--   <tt>Generator</tt> has a fixed element type, the input to the reducer
--   is generally known and extracting from the monoid usually is
--   sufficient to fix the result type. Combinators are available for most
--   scenarios where this is not the case, and the few remaining cases can
--   be handled by using an explicit type annotation.
--   
--   Minimal definition: <a>unit</a>
class Semigroup m => Reducer c m

-- | Convert a value into a <a>Semigroup</a>
unit :: Reducer c m => c -> m

-- | Append a value to a <a>Semigroup</a> for use in left-to-right
--   reduction
snoc :: Reducer c m => m -> c -> m

-- | Prepend a value onto a <a>Semigroup</a> for use during right-to-left
--   reduction
cons :: Reducer c m => c -> m -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable</a> container, after mapping
--   the contents into a suitable form for reduction.
foldMapReduce :: (Foldable f, Monoid m, Reducer e m) => (a -> e) -> f a -> m
foldMapReduce1 :: (Foldable1 f, Reducer e m) => (a -> e) -> f a -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable</a> mapping each element
--   through <a>unit</a>
foldReduce :: (Foldable f, Monoid m, Reducer e m) => f e -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable1</a> mapping each element
--   through <a>unit</a>
foldReduce1 :: (Foldable1 f, Reducer e m) => f e -> m
pureUnit :: (Applicative f, Reducer c n) => c -> f n
returnUnit :: (Monad m, Reducer c n) => c -> m n
newtype Count
Count :: Int -> Count
[getCount] :: Count -> Int
instance Data.Data.Data Data.Semigroup.Reducer.Count
instance GHC.Read.Read Data.Semigroup.Reducer.Count
instance GHC.Show.Show Data.Semigroup.Reducer.Count
instance GHC.Classes.Ord Data.Semigroup.Reducer.Count
instance GHC.Classes.Eq Data.Semigroup.Reducer.Count
instance Data.Hashable.Class.Hashable Data.Semigroup.Reducer.Count
instance GHC.Base.Semigroup Data.Semigroup.Reducer.Count
instance GHC.Base.Monoid Data.Semigroup.Reducer.Count
instance Data.Semigroup.Reducer.Reducer a Data.Semigroup.Reducer.Count
instance (Data.Semigroup.Reducer.Reducer c m, Data.Semigroup.Reducer.Reducer c n) => Data.Semigroup.Reducer.Reducer c (m, n)
instance (Data.Semigroup.Reducer.Reducer c m, Data.Semigroup.Reducer.Reducer c n, Data.Semigroup.Reducer.Reducer c o) => Data.Semigroup.Reducer.Reducer c (m, n, o)
instance (Data.Semigroup.Reducer.Reducer c m, Data.Semigroup.Reducer.Reducer c n, Data.Semigroup.Reducer.Reducer c o, Data.Semigroup.Reducer.Reducer c p) => Data.Semigroup.Reducer.Reducer c (m, n, o, p)
instance Data.Semigroup.Reducer.Reducer c [c]
instance Data.Semigroup.Reducer.Reducer c ()
instance Data.Semigroup.Reducer.Reducer GHC.Types.Bool Data.Semigroup.Internal.Any
instance Data.Semigroup.Reducer.Reducer GHC.Types.Bool Data.Semigroup.Internal.All
instance Data.Semigroup.Reducer.Reducer (a -> a) (Data.Semigroup.Internal.Endo a)
instance GHC.Base.Semigroup a => Data.Semigroup.Reducer.Reducer a (Data.Semigroup.Internal.Dual a)
instance GHC.Num.Num a => Data.Semigroup.Reducer.Reducer a (Data.Semigroup.Internal.Sum a)
instance GHC.Num.Num a => Data.Semigroup.Reducer.Reducer a (Data.Semigroup.Internal.Product a)
instance GHC.Classes.Ord a => Data.Semigroup.Reducer.Reducer a (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => Data.Semigroup.Reducer.Reducer a (Data.Semigroup.Max a)
instance Data.Semigroup.Reducer.Reducer (GHC.Maybe.Maybe a) (Data.Monoid.First a)
instance Data.Semigroup.Reducer.Reducer a (Data.Semigroup.First a)
instance Data.Semigroup.Reducer.Reducer (GHC.Maybe.Maybe a) (Data.Monoid.Last a)
instance Data.Semigroup.Reducer.Reducer a (Data.Semigroup.Last a)
instance Data.FingerTree.Measured v a => Data.Semigroup.Reducer.Reducer a (Data.FingerTree.FingerTree v a)
instance Data.Semigroup.Reducer.Reducer a (Data.Sequence.Internal.Seq a)
instance Data.Semigroup.Reducer.Reducer GHC.Types.Int Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord a => Data.Semigroup.Reducer.Reducer a (Data.Set.Internal.Set a)
instance Data.Semigroup.Reducer.Reducer (GHC.Types.Int, v) (Data.IntMap.Internal.IntMap v)
instance GHC.Classes.Ord k => Data.Semigroup.Reducer.Reducer (k, v) (Data.Map.Internal.Map k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Semigroup.Reducer.Reducer (k, v) (Data.HashMap.Internal.HashMap k v)
instance GHC.Base.Monoid m => Data.Semigroup.Reducer.Reducer m (Data.Semigroup.WrappedMonoid m)


-- | A semigroup for working with instances of <a>MonadPlus</a>
module Data.Semigroup.MonadPlus

-- | A <a>MonadSum</a> turns any <a>MonadPlus</a> instance into a
--   <a>Monoid</a>.
newtype MonadSum f a
MonadSum :: f a -> MonadSum f a
[getMonadSum] :: MonadSum f a -> f a
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (Data.Semigroup.MonadPlus.MonadSum f)
instance GHC.Base.Monad f => GHC.Base.Monad (Data.Semigroup.MonadPlus.MonadSum f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Semigroup.MonadPlus.MonadSum f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroup.MonadPlus.MonadSum f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.MonadPlus.MonadSum f)
instance GHC.Base.MonadPlus f => GHC.Base.Semigroup (Data.Semigroup.MonadPlus.MonadSum f a)
instance GHC.Base.MonadPlus f => GHC.Base.Monoid (Data.Semigroup.MonadPlus.MonadSum f a)
instance GHC.Base.MonadPlus f => Data.Semigroup.Reducer.Reducer (f a) (Data.Semigroup.MonadPlus.MonadSum f a)


-- | Semigroups for working with <a>Monad</a>s.
module Data.Semigroup.Monad

-- | A <a>Action</a> uses an glues together monadic actions with (&gt;&gt;)
--   in the manner of <a>mapM_</a> from <a>Data.Foldable</a>. Any values
--   returned by reduced actions are discarded.
newtype Action f
Action :: f () -> Action f
[getAction] :: Action f -> f ()
newtype Mon f m
Mon :: f m -> Mon f m
[getMon] :: Mon f m -> f m
instance GHC.Base.Monad f => GHC.Base.Monad (Data.Semigroup.Monad.Mon f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroup.Monad.Mon f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Monad.Mon f)
instance (GHC.Base.Monad f, GHC.Base.Semigroup m) => GHC.Base.Semigroup (Data.Semigroup.Monad.Mon f m)
instance (GHC.Base.Monad f, GHC.Base.Monoid m) => GHC.Base.Monoid (Data.Semigroup.Monad.Mon f m)
instance (GHC.Base.Monad f, Data.Semigroup.Reducer.Reducer c m) => Data.Semigroup.Reducer.Reducer (f c) (Data.Semigroup.Monad.Mon f m)
instance GHC.Base.Monad f => GHC.Base.Semigroup (Data.Semigroup.Monad.Action f)
instance GHC.Base.Monad f => GHC.Base.Monoid (Data.Semigroup.Monad.Action f)
instance GHC.Base.Monad f => Data.Semigroup.Reducer.Reducer (f a) (Data.Semigroup.Monad.Action f)


-- | Semigroups for working with <a>Apply</a>
module Data.Semigroup.Apply

-- | A <a>Trav</a> uses an glues together <a>Applicative</a> actions with
--   (*&gt;) in the manner of <tt>traverse_</tt> from <a>Data.Foldable</a>.
--   Any values returned by reduced actions are discarded.
newtype Trav f
Trav :: f () -> Trav f
[getTrav] :: Trav f -> f ()

-- | A <a>App</a> turns any <a>Apply</a> wrapped around a <a>Semigroup</a>
--   into a <a>Semigroup</a>
newtype App f m
App :: f m -> App f m
[getApp] :: App f m -> f m
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Semigroup.Apply.App f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Apply.App f)
instance (Data.Functor.Bind.Class.Apply f, GHC.Base.Semigroup m) => GHC.Base.Semigroup (Data.Semigroup.Apply.App f m)
instance (Data.Functor.Bind.Class.Apply f, Data.Semigroup.Reducer.Reducer c m) => Data.Semigroup.Reducer.Reducer (f c) (Data.Semigroup.Apply.App f m)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Data.Semigroup.Apply.Trav f)
instance Data.Functor.Bind.Class.Apply f => Data.Semigroup.Reducer.Reducer (f a) (Data.Semigroup.Apply.Trav f)


-- | Semigroups for working with <a>Applicative</a> <a>Functor</a>s.
module Data.Semigroup.Applicative

-- | A <a>Traversal</a> uses an glues together <a>Applicative</a> actions
--   with (*&gt;) in the manner of <tt>traverse_</tt> from
--   <a>Data.Foldable</a>. Any values returned by reduced actions are
--   discarded.
newtype Traversal f
Traversal :: f () -> Traversal f
[getTraversal] :: Traversal f -> f ()
newtype Ap f m
Ap :: f m -> Ap f m
[getAp] :: Ap f m -> f m
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroup.Applicative.Ap f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Applicative.Ap f)
instance (GHC.Base.Applicative f, GHC.Base.Semigroup m) => GHC.Base.Semigroup (Data.Semigroup.Applicative.Ap f m)
instance (GHC.Base.Applicative f, GHC.Base.Monoid m) => GHC.Base.Monoid (Data.Semigroup.Applicative.Ap f m)
instance (GHC.Base.Applicative f, Data.Semigroup.Reducer.Reducer c m) => Data.Semigroup.Reducer.Reducer (f c) (Data.Semigroup.Applicative.Ap f m)
instance GHC.Base.Applicative f => GHC.Base.Semigroup (Data.Semigroup.Applicative.Traversal f)
instance GHC.Base.Applicative f => GHC.Base.Monoid (Data.Semigroup.Applicative.Traversal f)
instance GHC.Base.Applicative f => Data.Semigroup.Reducer.Reducer (f a) (Data.Semigroup.Applicative.Traversal f)


-- | A semigroup for working with <a>Alternative</a> <a>Functor</a>s.
module Data.Semigroup.Alternative

-- | A <a>Alternate</a> turns any <a>Alternative</a> instance into a
--   <a>Monoid</a>.
newtype Alternate f a
Alternate :: f a -> Alternate f a
[getAlternate] :: Alternate f a -> f a
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Semigroup.Alternative.Alternate f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroup.Alternative.Alternate f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Alternative.Alternate f)
instance GHC.Base.Alternative f => GHC.Base.Semigroup (Data.Semigroup.Alternative.Alternate f a)
instance GHC.Base.Alternative f => GHC.Base.Monoid (Data.Semigroup.Alternative.Alternate f a)
instance GHC.Base.Alternative f => Data.Semigroup.Reducer.Reducer (f a) (Data.Semigroup.Alternative.Alternate f a)


-- | A semigroup for working <a>Alt</a> or <a>Plus</a>
module Data.Semigroup.Alt

-- | A <a>Alter</a> turns any <a>Alt</a> instance into a <a>Semigroup</a>.
newtype Alter f a
Alter :: f a -> Alter f a
[getAlter] :: Alter f a -> f a
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Semigroup.Alt.Alter f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Alt.Alter f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Semigroup.Alt.Alter f)
instance Data.Functor.Alt.Alt f => GHC.Base.Semigroup (Data.Semigroup.Alt.Alter f a)
instance Data.Functor.Plus.Plus f => GHC.Base.Monoid (Data.Semigroup.Alt.Alter f a)
instance Data.Functor.Alt.Alt f => Data.Semigroup.Reducer.Reducer (f a) (Data.Semigroup.Alt.Alter f a)


-- | A <a>Generator</a> <tt>c</tt> is a possibly-specialized container,
--   which contains values of type <a>Elem</a> <tt>c</tt>, and which knows
--   how to efficiently apply a <a>Reducer</a> to extract an answer.
--   
--   Since a <a>Generator</a> is not polymorphic in its contents, it is
--   more specialized than <a>Data.Foldable.Foldable</a>, and a
--   <a>Reducer</a> may supply efficient left-to-right and right-to-left
--   reduction strategies that a <a>Generator</a> may avail itself of.
module Data.Generator

-- | minimal definition <a>mapReduce</a> or <a>mapTo</a>
class Generator c where {
    type family Elem c;
}
mapReduce :: (Generator c, Reducer e m, Monoid m) => (Elem c -> e) -> c -> m
mapTo :: (Generator c, Reducer e m, Monoid m) => (Elem c -> e) -> m -> c -> m
mapFrom :: (Generator c, Reducer e m, Monoid m) => (Elem c -> e) -> c -> m -> m

-- | a <a>Generator</a> transformer that asks only for the keys of an
--   indexed container
newtype Keys c
Keys :: c -> Keys c
[getKeys] :: Keys c -> c

-- | a <a>Generator</a> transformer that asks only for the values contained
--   in an indexed container
newtype Values c
Values :: c -> Values c
[getValues] :: Values c -> c

-- | a <a>Generator</a> transformer that treats <a>Word8</a> as <a>Char</a>
--   This lets you use a <tt>ByteString</tt> as a <a>Char</a> source
--   without going through a <a>Monoid</a> transformer like <tt>UTF8</tt>
newtype Char8 c
Char8 :: c -> Char8 c
[getChar8] :: Char8 c -> c

-- | Apply a <a>Reducer</a> directly to the elements of a <a>Generator</a>
reduce :: (Generator c, Reducer (Elem c) m, Monoid m) => c -> m
mapReduceWith :: (Generator c, Reducer e m, Monoid m) => (m -> n) -> (Elem c -> e) -> c -> n
reduceWith :: (Generator c, Reducer (Elem c) m, Monoid m) => (m -> n) -> c -> n
instance Data.Generator.Generator (Data.Generator.Char8 Data.ByteString.Internal.ByteString)
instance Data.Generator.Generator (Data.Generator.Char8 Data.ByteString.Lazy.Internal.ByteString)
instance Data.Generator.Generator (Data.Generator.Values (Data.IntMap.Internal.IntMap v))
instance Data.Generator.Generator (Data.Generator.Values (Data.Map.Internal.Map k v))
instance Data.Generator.Generator (Data.Generator.Values (GHC.Arr.Array i e))
instance Data.Generator.Generator (Data.Generator.Keys (Data.IntMap.Internal.IntMap v))
instance Data.Generator.Generator (Data.Generator.Keys (Data.Map.Internal.Map k v))
instance GHC.Ix.Ix i => Data.Generator.Generator (Data.Generator.Keys (GHC.Arr.Array i e))
instance Data.Generator.Generator Data.ByteString.Internal.ByteString
instance Data.Generator.Generator Data.ByteString.Lazy.Internal.ByteString
instance Data.Generator.Generator Data.Text.Internal.Text
instance Data.Generator.Generator [c]
instance Data.Generator.Generator (GHC.Base.NonEmpty c)
instance Data.Generator.Generator (Data.FingerTree.FingerTree v e)
instance Data.Generator.Generator (Data.Sequence.Internal.Seq c)
instance Data.Generator.Generator Data.IntSet.Internal.IntSet
instance Data.Generator.Generator (Data.HashSet.Internal.HashSet a)
instance Data.Generator.Generator (Data.Set.Internal.Set a)
instance Data.Generator.Generator (Data.IntMap.Internal.IntMap v)
instance Data.Generator.Generator (Data.Map.Internal.Map k v)
instance Data.Generator.Generator (Data.HashMap.Internal.HashMap k v)
instance GHC.Ix.Ix i => Data.Generator.Generator (GHC.Arr.Array i e)


-- | A <a>Generator1</a> <tt>c</tt> is a possibly-specialized container,
--   which contains values of type <a>Elem</a> <tt>c</tt>, and which knows
--   how to efficiently apply a <a>Reducer</a> to extract an answer.
--   
--   <a>Generator1</a> is to <a>Generator</a> as <a>Foldable1</a> is to
--   <a>Foldable</a>.
module Data.Semigroup.Generator

-- | minimal definition <a>mapReduce1</a> or <a>mapTo1</a>
class Generator c => Generator1 c
mapReduce1 :: (Generator1 c, Reducer e m) => (Elem c -> e) -> c -> m
mapTo1 :: (Generator1 c, Reducer e m) => (Elem c -> e) -> m -> c -> m
mapFrom1 :: (Generator1 c, Reducer e m) => (Elem c -> e) -> c -> m -> m

-- | Apply a <a>Reducer</a> directly to the elements of a <a>Generator</a>
reduce1 :: (Generator1 c, Reducer (Elem c) m) => c -> m
mapReduceWith1 :: (Generator1 c, Reducer e m) => (m -> n) -> (Elem c -> e) -> c -> n
reduceWith1 :: (Generator1 c, Reducer (Elem c) m) => (m -> n) -> c -> n
instance Data.Semigroup.Generator.Generator1 (GHC.Base.NonEmpty e)


-- | Utilities for working with Monoids that conflict with names from the
--   <a>Prelude</a>, <a>Data.Foldable</a>, <a>Control.Monad</a> or
--   elsewhere. Intended to be imported qualified.
--   
--   <pre>
--   import Data.Generator.Combinators as Generator
--   </pre>
module Data.Generator.Combinators

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>Action</a> monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a> and <a>Control.Monad</a>
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAction</a>
--   </pre>
mapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()

-- | Convenience function as found in <a>Data.Foldable</a> and
--   <a>Control.Monad</a>
--   
--   <pre>
--   <a>flip</a> <a>mapM_</a>
--   </pre>
forM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getMonadSum</a>
--   </pre>
msum :: (Generator c, MonadPlus m, m a ~ Elem c) => c -> m a

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>Traversal</a> monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a>
--   
--   <pre>
--   <a>mapReduce</a> <a>getTraversal</a>
--   </pre>
traverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()

-- | Convenience function as found in <a>Data.Foldable</a>
--   
--   <pre>
--   <a>flip</a> <a>traverse_</a>
--   </pre>
for_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>
--   
--   <pre>
--   <a>reduceWith</a> <tt>getAlt</tt>
--   </pre>
asum :: (Generator c, Alternative f, f a ~ Elem c) => c -> f a

-- | Efficiently <a>reduce</a> a <a>Generator</a> that contains values of
--   type <a>Bool</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAll</a>
--   </pre>
and :: (Generator c, Elem c ~ Bool) => c -> Bool

-- | Efficiently <a>reduce</a> a <a>Generator</a> that contains values of
--   type <a>Bool</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAny</a>
--   </pre>
or :: (Generator c, Elem c ~ Bool) => c -> Bool

-- | Efficiently <a>mapReduce</a> any <a>Generator</a> checking to see if
--   any of its values match the supplied predicate
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAny</a>
--   </pre>
any :: Generator c => (Elem c -> Bool) -> c -> Bool

-- | Efficiently <a>mapReduce</a> any <a>Generator</a> checking to see if
--   all of its values match the supplied predicate
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAll</a>
--   </pre>
all :: Generator c => (Elem c -> Bool) -> c -> Bool

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>WrappedMonoid</a> monoid. A specialized version of its namesake
--   from <a>Data.Foldable</a>
--   
--   <pre>
--   <a>mapReduceWith</a> <a>unwrapMonoid</a>
--   </pre>
foldMap :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m

-- | Efficiently <a>reduce</a> a <a>Generator</a> using the
--   <a>WrappedMonoid</a> monoid. A specialized version of its namesake
--   from <a>Data.Foldable</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>unwrapMonoid</a>
--   </pre>
fold :: (Monoid m, Generator c, Elem c ~ m) => c -> m

-- | Convert any <a>Generator</a> to a list of its contents. Specialization
--   of <a>reduce</a>
toList :: Generator c => c -> [Elem c]

-- | Type specialization of "foldMap" above
concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]

-- | Check to see if <a>any</a> member of the <a>Generator</a> matches the
--   supplied value
elem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool

-- | Efficiently <a>mapReduce</a> a subset of the elements in a
--   <a>Generator</a>
filter :: (Generator c, Reducer (Elem c) m, Monoid m) => (Elem c -> Bool) -> c -> m

-- | Allows idiomatic specialization of filter by proving a function that
--   will be used to transform the output
filterWith :: (Generator c, Reducer (Elem c) m, Monoid m) => (m -> n) -> (Elem c -> Bool) -> c -> n

-- | Efficiently sum over the members of any <a>Generator</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getSum</a>
--   </pre>
sum :: (Generator c, Num (Elem c)) => c -> Elem c

-- | Efficiently take the product of every member of a <a>Generator</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getProduct</a>
--   </pre>
product :: (Generator c, Num (Elem c)) => c -> Elem c

-- | Check to make sure that the supplied value is not a member of the
--   <a>Generator</a>
notElem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool


module Data.Semigroup.Reducer.With

-- | If <tt>m</tt> is a <tt>c</tt>-<a>Reducer</a>, then m is <tt>(c
--   <a>WithReducer</a> m)</tt>-<a>Reducer</a> This can be used to quickly
--   select a <a>Reducer</a> for use as a <a>FingerTree</a> <a>measure</a>.
newtype WithReducer m c
WithReducer :: c -> WithReducer m c
[withoutReducer] :: WithReducer m c -> c
instance GHC.Read.Read c => GHC.Read.Read (Data.Semigroup.Reducer.With.WithReducer m c)
instance GHC.Show.Show c => GHC.Show.Show (Data.Semigroup.Reducer.With.WithReducer m c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (Data.Semigroup.Reducer.With.WithReducer m c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Data.Semigroup.Reducer.With.WithReducer m c)
instance Data.Hashable.Class.Hashable c => Data.Hashable.Class.Hashable (Data.Semigroup.Reducer.With.WithReducer m c)
instance GHC.Base.Functor (Data.Semigroup.Reducer.With.WithReducer m)
instance Data.Foldable.Foldable (Data.Semigroup.Reducer.With.WithReducer m)
instance Data.Traversable.Traversable (Data.Semigroup.Reducer.With.WithReducer m)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.Semigroup.Reducer.With.WithReducer m)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Semigroup.Reducer.With.WithReducer m)
instance Data.Semigroup.Reducer.Reducer c m => Data.Semigroup.Reducer.Reducer (Data.Semigroup.Reducer.With.WithReducer m c) m
instance (GHC.Base.Monoid m, Data.Semigroup.Reducer.Reducer c m) => Data.FingerTree.Measured m (Data.Semigroup.Reducer.With.WithReducer m c)


-- | A simple <a>Monoid</a> transformer that takes a <a>Monoid</a> m and
--   produces a new <tt>m</tt>-Reducer named <a>Self</a> <tt>m</tt>
--   
--   This is useful when you have a generator that already contains
--   monoidal values or someone supplies the map to the monoid in the form
--   of a function rather than as a <a>Reducer</a> instance. You can just
--   <tt><a>getSelf</a> . <tt>reduce</tt></tt> or <tt><a>getSelf</a> .
--   <tt>mapReduce</tt> f</tt> in those scenarios. These behaviors are
--   encapsulated into the <tt>fold</tt> and <a>foldMap</a> combinators in
--   <a>Data.Monoid.Combinators</a> respectively.
module Data.Semigroup.Self
newtype Self m
Self :: m -> Self m
[getSelf] :: Self m -> m
instance GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.Self.Self m)
instance GHC.Base.Semigroup m => GHC.Base.Semigroup (Data.Semigroup.Self.Self m)
instance GHC.Base.Semigroup m => Data.Semigroup.Reducer.Reducer m (Data.Semigroup.Self.Self m)
instance GHC.Base.Functor Data.Semigroup.Self.Self
instance Data.Foldable.Foldable Data.Semigroup.Self.Self
instance Data.Traversable.Traversable Data.Semigroup.Self.Self
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Self.Self
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Self.Self

module Data.Semigroup.Union

-- | A Container suitable for the <a>Union</a> <a>Monoid</a>
class HasUnion f
union :: HasUnion f => f -> f -> f
class HasUnion f => HasUnion0 f
empty :: HasUnion0 f => f

-- | The <a>Monoid</a> <tt>(<a>union</a>,<a>empty</a>)</tt>
newtype Union f
Union :: f -> Union f
[getUnion] :: Union f -> f

-- | Polymorphic containers that we can supply an operation to handle
--   unions with
class Functor f => HasUnionWith f
unionWith :: HasUnionWith f => (a -> a -> a) -> f a -> f a -> f a
class HasUnionWith f => HasUnionWith0 f
emptyWith :: HasUnionWith0 f => f a

-- | The <a>Monoid</a> <tt>('unionWith mappend',<a>empty</a>)</tt> for
--   containers full of monoids.
newtype UnionWith f m
UnionWith :: f m -> UnionWith f m
[getUnionWith] :: UnionWith f m -> f m
instance GHC.Read.Read f => GHC.Read.Read (Data.Semigroup.Union.Union f)
instance GHC.Show.Show f => GHC.Show.Show (Data.Semigroup.Union.Union f)
instance GHC.Classes.Ord f => GHC.Classes.Ord (Data.Semigroup.Union.Union f)
instance GHC.Classes.Eq f => GHC.Classes.Eq (Data.Semigroup.Union.Union f)
instance (Data.Semigroup.Union.HasUnionWith f, GHC.Base.Semigroup m) => GHC.Base.Semigroup (Data.Semigroup.Union.UnionWith f m)
instance (Data.Semigroup.Union.HasUnionWith0 f, GHC.Base.Monoid m) => GHC.Base.Monoid (Data.Semigroup.Union.UnionWith f m)
instance (Data.Semigroup.Union.HasUnionWith f, GHC.Base.Semigroup m, GHC.Base.Monoid m) => Data.Semigroup.Reducer.Reducer (f m) (Data.Semigroup.Union.UnionWith f m)
instance Data.Semigroup.Union.HasUnionWith0 Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Data.Semigroup.Union.HasUnionWith0 (Data.Map.Internal.Map k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Semigroup.Union.HasUnionWith0 (Data.HashMap.Internal.HashMap k)
instance Data.Semigroup.Union.HasUnionWith Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Data.Semigroup.Union.HasUnionWith (Data.Map.Internal.Map k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Semigroup.Union.HasUnionWith (Data.HashMap.Internal.HashMap k)
instance Data.Semigroup.Union.HasUnion f => GHC.Base.Semigroup (Data.Semigroup.Union.Union f)
instance Data.Semigroup.Union.HasUnion0 f => GHC.Base.Monoid (Data.Semigroup.Union.Union f)
instance Data.Semigroup.Union.HasUnion f => Data.Semigroup.Reducer.Reducer f (Data.Semigroup.Union.Union f)
instance GHC.Base.Functor Data.Semigroup.Union.Union
instance Data.Foldable.Foldable Data.Semigroup.Union.Union
instance Data.Traversable.Traversable Data.Semigroup.Union.Union
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Union.Union
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Union.Union
instance Data.Semigroup.Union.HasUnion0 (Data.IntMap.Internal.IntMap a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Semigroup.Union.HasUnion0 (Data.HashMap.Internal.HashMap k a)
instance GHC.Classes.Ord k => Data.Semigroup.Union.HasUnion0 (Data.Map.Internal.Map k a)
instance GHC.Classes.Eq a => Data.Semigroup.Union.HasUnion0 [a]
instance GHC.Classes.Ord a => Data.Semigroup.Union.HasUnion0 (Data.Set.Internal.Set a)
instance Data.Semigroup.Union.HasUnion0 Data.IntSet.Internal.IntSet
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Semigroup.Union.HasUnion0 (Data.HashSet.Internal.HashSet a)
instance Data.Semigroup.Union.HasUnion (Data.IntMap.Internal.IntMap a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Semigroup.Union.HasUnion (Data.HashMap.Internal.HashMap k a)
instance GHC.Classes.Ord k => Data.Semigroup.Union.HasUnion (Data.Map.Internal.Map k a)
instance GHC.Classes.Eq a => Data.Semigroup.Union.HasUnion [a]
instance GHC.Classes.Ord a => Data.Semigroup.Union.HasUnion (Data.Set.Internal.Set a)
instance Data.Semigroup.Union.HasUnion Data.IntSet.Internal.IntSet
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Semigroup.Union.HasUnion (Data.HashSet.Internal.HashSet a)
