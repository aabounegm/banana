-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/aabounegm/banana#readme</a>
@package banana
@version 0.1.0.0


-- | Given the intermediate representation from the semantic checker, the
--   code generator builds the LLVM code for that program.
module Banana.CodeGen.LLVM


-- | This module holds the data types that are uses to represent the parsed
--   program.
module Banana.Syntax.AST

-- | The possible types in the Banana language
data Type
Number :: Type
Array :: Integer -> Type -> Type
Void :: Type

-- | A variable declaration of the form "var x: num"
data VarDecl a
VarDecl :: a -> Type -> VarDecl a
[varName] :: VarDecl a -> a
[varType] :: VarDecl a -> Type

-- | Function call, with the same representation as for expressions
data FuncCall a
FuncCall :: a -> [Expr a] -> FuncCall a
[func] :: FuncCall a -> a
[args] :: FuncCall a -> [Expr a]

-- | An arithmetic expression
data Expr a

-- | Addition (+)
Add :: Expr a -> Expr a -> Expr a

-- | Subtraction (-)
Sub :: Expr a -> Expr a -> Expr a

-- | Multiplication (*)
Mul :: Expr a -> Expr a -> Expr a

-- | Division (/)
Div :: Expr a -> Expr a -> Expr a

-- | Variable (identifier)
Var :: a -> Expr a

-- | A literal value
Lit :: Double -> Expr a

-- | Unary logical not (<a>not</a>)
Not :: Expr a -> Expr a

-- | Logical OR (<a>or</a>)
Or :: Expr a -> Expr a -> Expr a

-- | Logical AND (<a>and</a>)
And :: Expr a -> Expr a -> Expr a

-- | Equal to (=)
Eq :: Expr a -> Expr a -> Expr a

-- | Not Equal to (/=)
NEq :: Expr a -> Expr a -> Expr a

-- | Less than (&lt;)
Less :: Expr a -> Expr a -> Expr a

-- | Bigger than (&gt;)
More :: Expr a -> Expr a -> Expr a

-- | Less than or Equal to (&lt;=)
LEq :: Expr a -> Expr a -> Expr a

-- | Bigger than or Equal to (&gt;=)
MEq :: Expr a -> Expr a -> Expr a

-- | A function call as an expression
FuncCallExpr :: FuncCall a -> Expr a

-- | A variable assignment of the form "x := y"
data VarAssign a
VarAssign :: Expr a -> Expr a -> VarAssign a

-- | LHS
[varAssignee] :: VarAssign a -> Expr a

-- | RHS
[varExpr] :: VarAssign a -> Expr a

-- | A definition of if statement
data IfStatement a
If :: [Expr a] -> [Statement a] -> IfStatement a
[condition] :: IfStatement a -> [Expr a]
[statement] :: IfStatement a -> [Statement a]

-- | A wrapper to collect all statement types together
data Statement a
VarDeclaration :: VarDecl a -> Statement a
VarAssignment :: VarAssign a -> Statement a
FuncCallStatement :: FuncCall a -> Statement a
IfStatement :: IfStatement a -> Statement a

-- | A function definition
data Function a
Function :: [VarDecl a] -> Type -> [Statement a] -> Function a
[params] :: Function a -> [VarDecl a]
[returnType] :: Function a -> Type
[body] :: Function a -> [Statement a]

-- | The AST node representing the entire program with all of its
--   structures
data Program a
Program :: [Statement a] -> [Function a] -> Program a
[statements] :: Program a -> [Statement a]
[functions] :: Program a -> [Function a]
varDecls :: Program a -> [VarDecl a]
assignments :: Program a -> [VarAssign a]
ifStatements :: Program a -> [IfStatement a]
instance GHC.Classes.Eq Banana.Syntax.AST.Type
instance GHC.Show.Show Banana.Syntax.AST.Type
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.VarDecl a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.VarDecl a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.FuncCall a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.FuncCall a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.Expr a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.VarAssign a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.VarAssign a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.IfStatement a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.IfStatement a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.Statement a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.Statement a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.Function a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.Function a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Banana.Syntax.AST.Program a)
instance GHC.Show.Show a => GHC.Show.Show (Banana.Syntax.AST.Program a)


-- | The lexer is responsible for taking the source code as a string and
--   cutting it into tokens.
module Banana.Syntax.Lexer


-- | The parser gets fed the token generated by the lexer and generates an
--   AST from them representing the program.
module Banana.Syntax.Parser

-- | Parse a type
parseType :: Parser Type

-- | Parse variable declarations
parseVarDecl :: Parser (VarDecl String)

-- | Parse an arithmetic expression
parseExpr :: Parser (Expr String)

-- | Parse the variable assignment statement
parseVarAssign :: Parser (VarAssign String)

-- | Parse a program consisting of variable declarations and assignments
parseProgram :: Parser (Program String)

-- | Parse a function call
parseFuncCall :: Parser (FuncCall String)


-- | Given the parsed AST, the Semantic Checker verifies that the input
--   program is valid and transforms the AST into another intermediate
--   representation for code generation.
module Banana.TypeCheck.Checker

-- | Checks if a given expression is a valid LHS in an assignment
validLHS :: Expr a -> Bool

-- | Looks up the variable declaration that declares a given variable
varToReference :: Eq a => Expr a -> [VarDecl a] -> Maybe (VarDecl a)

-- | Checks if all assignments are valid
assignmentsAreValid :: Program a -> Bool

-- | Checks that no 2 variables are declared with the same name
varDeclsAreUnique :: Eq a => Program a -> Bool

-- | Checks that all variables used in expressions are declared beforehand
allVarsDeclared :: Eq a => Program a -> Bool

-- | Runs all the checkers, combining their output
checkAll :: Eq a => Program a -> Bool


-- | The modified AST that is ready to be used for code generation.
module Banana.TypeCheck.IR
