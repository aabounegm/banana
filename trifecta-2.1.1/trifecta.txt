-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A modern parser combinator library with convenient diagnostics
--   
--   A modern parser combinator library with slicing and Clang-style
--   colored diagnostics
--   
--   For example:
--   
--   
--   <a>(Local Copy)</a>
@package trifecta
@version 2.1.1


-- | Interval maps implemented using the <a>FingerTree</a> type, following
--   section 4.8 of
--   
--   <ul>
--   <li>Ralf Hinze and Ross Paterson, "Finger trees: a simple
--   general-purpose data structure", <i>Journal of Functional
--   Programming</i> 16:2 (2006) pp 197-217.
--   <a>http://www.soi.city.ac.uk/~ross/papers/FingerTree.html</a></li>
--   </ul>
--   
--   An amortized running time is given for each operation, with <i>n</i>
--   referring to the size of the priority queue. These bounds hold even in
--   a persistent (shared) setting.
--   
--   <i>Note</i>: Many of these operations have the same names as similar
--   operations on lists in the <a>Prelude</a>. The ambiguity may be
--   resolved using either qualification or the <tt>hiding</tt> clause.
--   
--   Unlike <a>Data.IntervalMap.FingerTree</a>, this version sorts things
--   so that the largest interval from a given point comes first. This way
--   if you have nested intervals, you get the outermost interval before
--   the contained intervals.
module Text.Trifecta.Util.IntervalMap

-- | A closed interval. The lower bound should be less than or equal to the
--   higher bound.
data Interval v
Interval :: v -> v -> Interval v
[low] :: Interval v -> v
[high] :: Interval v -> v

-- | Map of closed intervals, possibly with duplicates. The <a>Foldable</a>
--   and <a>Traversable</a> instances process the intervals in
--   lexicographical order.
newtype IntervalMap v a
IntervalMap :: FingerTree (IntInterval v) (Node v a) -> IntervalMap v a
[runIntervalMap] :: IntervalMap v a -> FingerTree (IntInterval v) (Node v a)

-- | <i>O(1)</i>. Interval map with a single entry.
singleton :: Ord v => Interval v -> a -> IntervalMap v a

-- | <i>O(log n)</i>. Insert an interval into a map. The map may contain
--   duplicate intervals; the new entry will be inserted before any
--   existing entries for the same interval.
insert :: Ord v => v -> v -> a -> IntervalMap v a -> IntervalMap v a

-- | <i>O(k log (n</i>/<i>k))</i>. All intervals that contain the given
--   point, in lexicographical order.
search :: Ord v => v -> IntervalMap v a -> [(Interval v, a)]

-- | <i>O(k log (n</i>/<i>k))</i>. All intervals that intersect with the
--   given interval, in lexicographical order.
intersections :: Ord v => v -> v -> IntervalMap v a -> [(Interval v, a)]

-- | <i>O(k log (n</i>/<i>k))</i>. All intervals that contain the given
--   interval, in lexicographical order.
dominators :: Ord v => v -> v -> IntervalMap v a -> [(Interval v, a)]

-- | <i>O(n)</i>. Add a delta to each interval in the map
offset :: (Ord v, Monoid v) => v -> IntervalMap v a -> IntervalMap v a
data IntInterval v
NoInterval :: IntInterval v
IntInterval :: Interval v -> v -> IntInterval v
fromList :: Ord v => [(v, v, a)] -> IntervalMap v a
instance GHC.Show.Show v => GHC.Show.Show (Text.Trifecta.Util.IntervalMap.Interval v)
instance GHC.Base.Functor (Text.Trifecta.Util.IntervalMap.IntervalMap v)
instance Control.Lens.Indexed.FunctorWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.IntervalMap v)
instance Data.Foldable.Foldable (Text.Trifecta.Util.IntervalMap.IntervalMap v)
instance Control.Lens.Indexed.FoldableWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.IntervalMap v)
instance Data.Traversable.Traversable (Text.Trifecta.Util.IntervalMap.IntervalMap v)
instance Control.Lens.Indexed.TraversableWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.IntervalMap v)
instance GHC.Classes.Ord v => Data.FingerTree.Measured (Text.Trifecta.Util.IntervalMap.IntInterval v) (Text.Trifecta.Util.IntervalMap.IntervalMap v a)
instance GHC.Classes.Ord v => Data.Semigroup.Union.HasUnion (Text.Trifecta.Util.IntervalMap.IntervalMap v a)
instance GHC.Classes.Ord v => Data.Semigroup.Union.HasUnion0 (Text.Trifecta.Util.IntervalMap.IntervalMap v a)
instance GHC.Classes.Ord v => GHC.Base.Monoid (Text.Trifecta.Util.IntervalMap.IntervalMap v a)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Text.Trifecta.Util.IntervalMap.IntervalMap v a)
instance GHC.Classes.Ord v => GHC.Base.Monoid (Text.Trifecta.Util.IntervalMap.IntInterval v)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Text.Trifecta.Util.IntervalMap.IntInterval v)
instance GHC.Classes.Ord v => Data.FingerTree.Measured (Text.Trifecta.Util.IntervalMap.IntInterval v) (Text.Trifecta.Util.IntervalMap.Node v a)
instance GHC.Base.Functor (Text.Trifecta.Util.IntervalMap.Node v)
instance WithIndex.FunctorWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.Node v)
instance Data.Foldable.Foldable (Text.Trifecta.Util.IntervalMap.Node v)
instance WithIndex.FoldableWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.Node v)
instance Data.Traversable.Traversable (Text.Trifecta.Util.IntervalMap.Node v)
instance WithIndex.TraversableWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.Node v)
instance Control.Lens.Indexed.FunctorWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.Node v)
instance Control.Lens.Indexed.FoldableWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.Node v)
instance Control.Lens.Indexed.TraversableWithIndex (Text.Trifecta.Util.IntervalMap.Interval v) (Text.Trifecta.Util.IntervalMap.Node v)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Text.Trifecta.Util.IntervalMap.Interval v)
instance (GHC.Classes.Ord v, GHC.Base.Monoid v) => Data.Semigroup.Reducer.Reducer v (Text.Trifecta.Util.IntervalMap.Interval v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Text.Trifecta.Util.IntervalMap.Interval v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Text.Trifecta.Util.IntervalMap.Interval v)
instance GHC.Base.Functor Text.Trifecta.Util.IntervalMap.Interval
instance Data.Foldable.Foldable Text.Trifecta.Util.IntervalMap.Interval
instance Data.Traversable.Traversable Text.Trifecta.Util.IntervalMap.Interval


-- | A <a>Delta</a> keeps track of the cursor position of the parser, so it
--   can be referred to later, for example in error messages.
module Text.Trifecta.Delta

-- | Since there are multiple ways to be at a certain location,
--   <a>Delta</a> captures all these alternatives as a single type.
data Delta

-- | <pre>
--   ( number of characters
--   , number of bytes )
--   </pre>
Columns :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta

-- | <pre>
--   ( number of characters before the tab
--   , number of characters after the tab
--   , number of bytes )
--   </pre>
Tab :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta

-- | <pre>
--   ( number of newlines contained
--   , number of characters since the last newline
--   , number of bytes
--   , number of bytes since the last newline )
--   </pre>
Lines :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta

-- | <pre>
--   ( current file name
--   , number of lines since the last line directive
--   , number of characters since the last newline
--   , number of bytes
--   , number of bytes since the last newline )
--   </pre>
Directed :: !ByteString -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
class HasDelta t
delta :: HasDelta t => t -> Delta
class HasBytes t
bytes :: HasBytes t => t -> Int64

-- | Example: <tt>file.txt:12:34</tt>
prettyDelta :: Delta -> Doc AnsiStyle

-- | Increment a column number to the next tabstop.
nextTab :: Int64 -> Int64

-- | Rewind a <a>Delta</a> to the beginning of the line.
rewind :: Delta -> Delta

-- | Should we show two things with a <a>Delta</a> on the same line?
--   
--   <pre>
--   &gt;&gt;&gt; near (Columns 0 0) (Columns 5 5)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; near (Lines 1 0 1 0) (Lines 2 4 4 2)
--   False
--   </pre>
near :: (HasDelta s, HasDelta t) => s -> t -> Bool

-- | Retrieve the character offset within the current line from this
--   <a>Delta</a>.
column :: HasDelta t => t -> Int64

-- | Retrieve the byte offset within the current line from this
--   <a>Delta</a>.
columnByte :: Delta -> Int64
instance GHC.Generics.Generic Text.Trifecta.Delta.Delta
instance Data.Data.Data Text.Trifecta.Delta.Delta
instance GHC.Show.Show Text.Trifecta.Delta.Delta
instance (Text.Trifecta.Delta.HasDelta l, Text.Trifecta.Delta.HasDelta r) => Text.Trifecta.Delta.HasDelta (Data.Either.Either l r)
instance Text.Trifecta.Delta.HasDelta Text.Trifecta.Delta.Delta
instance Text.Trifecta.Delta.HasDelta GHC.Types.Char
instance Text.Trifecta.Delta.HasDelta GHC.Word.Word8
instance Text.Trifecta.Delta.HasDelta Data.ByteString.Internal.ByteString
instance (Data.FingerTree.Measured v a, Text.Trifecta.Delta.HasDelta v) => Text.Trifecta.Delta.HasDelta (Data.FingerTree.FingerTree v a)
instance GHC.Classes.Eq Text.Trifecta.Delta.Delta
instance GHC.Classes.Ord Text.Trifecta.Delta.Delta
instance Text.Trifecta.Delta.HasBytes Text.Trifecta.Delta.Delta
instance Data.Hashable.Class.Hashable Text.Trifecta.Delta.Delta
instance GHC.Base.Monoid Text.Trifecta.Delta.Delta
instance GHC.Base.Semigroup Text.Trifecta.Delta.Delta
instance Text.Trifecta.Delta.HasBytes Data.ByteString.Internal.ByteString
instance (Data.FingerTree.Measured v a, Text.Trifecta.Delta.HasBytes v) => Text.Trifecta.Delta.HasBytes (Data.FingerTree.FingerTree v a)


-- | A rope is a data strucure to efficiently store and manipulate long
--   strings. Wikipedia provides a nice overview:
--   <a>https://en.wikipedia.org/wiki/Rope_(data_structure)</a>
module Text.Trifecta.Rope
data Rope
Rope :: !Delta -> !FingerTree Delta Strand -> Rope
rope :: FingerTree Delta Strand -> Rope

-- | Construct a <a>Rope</a> out of a single <a>ByteString</a> strand.
ropeBS :: ByteString -> Rope
data Strand

-- | Data of a certain length
Strand :: {-# UNPACK #-} !ByteString -> !Delta -> Strand

-- | Absence of data of a certain length
Skipping :: !Delta -> Strand

-- | Construct a single <a>Strand</a> out of a <a>ByteString</a>.
strand :: ByteString -> Strand
strands :: Rope -> FingerTree Delta Strand

-- | Grab the entire rest of the input <a>Rope</a>, starting at an initial
--   offset, or return a default if we’re already at or beyond the end.
--   Also see <a>grabLine</a>.
--   
--   Extract a suffix of a certain length from the input:
--   
--   <pre>
--   &gt;&gt;&gt; grabRest (delta ("Hello " :: ByteString)) (ropeBS "Hello World\nLorem") Nothing (\x y -&gt; Just (x, Lazy.toString y))
--   Just (Columns 6 6,"World\nLorem")
--   </pre>
--   
--   Same deal, but over multiple strands:
--   
--   <pre>
--   &gt;&gt;&gt; grabRest (delta ("Hel" :: ByteString)) (ropeBS "Hello" &lt;&gt; ropeBS "World") Nothing (\x y -&gt; Just (x, Lazy.toString y))
--   Just (Columns 3 3,"loWorld")
--   </pre>
--   
--   When the offset is too long, fall back to a default:
--   
--   <pre>
--   &gt;&gt;&gt; grabRest (delta ("OffetTooLong" :: ByteString)) (ropeBS "Hello") Nothing (\x y -&gt; Just (x, Lazy.toString y))
--   Nothing
--   </pre>
grabRest :: Delta -> Rope -> r -> (Delta -> ByteString -> r) -> r

-- | Grab the rest of the line at a certain offset in the input
--   <a>Rope</a>, or return a default if there is no newline left in the
--   input. Also see <a>grabRest</a>.
--   
--   <pre>
--   &gt;&gt;&gt; grabLine (delta ("Hello " :: ByteString)) (ropeBS "Hello" &lt;&gt; ropeBS " World\nLorem") Nothing (\x y -&gt; Just (x, Strict.toString y))
--   Just (Columns 6 6,"World\n")
--   </pre>
grabLine :: Delta -> Rope -> r -> (Delta -> ByteString -> r) -> r
instance GHC.Generics.Generic Text.Trifecta.Rope.Strand
instance Data.Data.Data Text.Trifecta.Rope.Strand
instance GHC.Show.Show Text.Trifecta.Rope.Strand
instance GHC.Show.Show Text.Trifecta.Rope.Rope
instance Text.Trifecta.Delta.HasBytes Text.Trifecta.Rope.Rope
instance Text.Trifecta.Delta.HasDelta Text.Trifecta.Rope.Rope
instance Data.FingerTree.Measured Text.Trifecta.Delta.Delta Text.Trifecta.Rope.Rope
instance GHC.Base.Monoid Text.Trifecta.Rope.Rope
instance GHC.Base.Semigroup Text.Trifecta.Rope.Rope
instance Data.Semigroup.Reducer.Reducer Text.Trifecta.Rope.Rope Text.Trifecta.Rope.Rope
instance Data.Semigroup.Reducer.Reducer Text.Trifecta.Rope.Strand Text.Trifecta.Rope.Rope
instance Data.Semigroup.Reducer.Reducer Data.ByteString.Internal.ByteString Text.Trifecta.Rope.Rope
instance Data.Semigroup.Reducer.Reducer [GHC.Types.Char] Text.Trifecta.Rope.Rope
instance Data.FingerTree.Measured Text.Trifecta.Delta.Delta Text.Trifecta.Rope.Strand
instance Data.Hashable.Class.Hashable Text.Trifecta.Rope.Strand
instance Text.Trifecta.Delta.HasDelta Text.Trifecta.Rope.Strand
instance Text.Trifecta.Delta.HasBytes Text.Trifecta.Rope.Strand


-- | harder, better, faster, stronger...
module Text.Trifecta.Util.It

-- | <tt><a>It</a></tt> is an <a>Iteratee</a> that can produce partial
--   results.
--   
--   <tt><a>It</a> r a</tt> consumes a feed of <tt>r</tt>s and produces
--   <tt>a</tt>s on the way. New values can be fed using
--   <tt><a>simplifyIt</a></tt>, the current (partial or final) result is
--   extracted using <tt><a>extract</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let keepIt    a = Pure a
--   
--   &gt;&gt;&gt; let replaceIt a = It a replaceIt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (keepIt 0)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (replaceIt 0)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt (keepIt 0) 5)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt (replaceIt 0) 5)
--   5
--   </pre>
data It r a

-- | Final result, rest of the feed is discarded
Pure :: a -> It r a

-- | Intermediate result, consumed values produce new results
It :: a -> (r -> It r a) -> It r a

-- | Consumes input until a value can be produced.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let needTen = needIt 0 (\n -&gt; if n &lt; 10 then Nothing else Just n) :: It Int Int
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract needTen
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt needTen 5)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt needTen 11)
--   11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt (simplifyIt (simplifyIt needTen 5) 11) 15)
--   11
--   </pre>
needIt :: a -> (r -> Maybe a) -> It r a

-- | Consumes input and produces partial results until a condition is met.
--   Unlike <a>needIt</a>, partial results are already returned when the
--   condition is not fulfilled yet.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let wantTen :: It Int Int
--       wantTen = wantIt 0 (\n -&gt; (# n &gt;= 10, n #))
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract wantTen
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt wantTen 5)
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt wantTen 11)
--   11
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt (simplifyIt (simplifyIt wantTen 5) 11) 15)
--   11
--   </pre>
wantIt :: a -> (r -> (# Bool, a #)) -> It r a

-- | Feed a value to <a>It</a>, obtaining a new (partial or final) result.
simplifyIt :: It r a -> r -> It r a

-- | The generalized fold (Böhm-Berarducci decoding) over 'It r a'.
--   
--   <a>foldIt</a> satisfies the property:
--   
--   <pre>
--   foldIt Pure It = id
--   </pre>
foldIt :: (a -> o) -> (a -> (r -> o) -> o) -> It r a -> o

-- | Scott decoding of 'It r a'.
--   
--   The scott decoding is similar to the generalized fold over a data
--   type, but leaves the recursion step to the calling function.
--   
--   <a>runIt</a> satiesfies the property:
--   
--   <pre>
--   runIt Pure It = id
--   </pre>
--   
--   See also the Scott decoding of lists:
--   
--   <pre>
--   runList :: (a -&gt; [a] -&gt; b) -&gt; b -&gt; [a] -&gt; b
--   </pre>
--   
--   and compare it with <a>foldr</a> (the Böhm-Berarducci decoding for
--   lists):
--   
--   <pre>
--   foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
--   </pre>
runIt :: (a -> o) -> (a -> (r -> It r a) -> o) -> It r a -> o

-- | Given a position, go there, and grab the rest of the line forward from
--   that point.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let secondLine = fillIt Nothing (const Just) (delta ("foo\nb" :: Strict.ByteString))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract secondLine
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo"))
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo\nbar"))
--   Just "ar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo\nbar\nbaz"))
--   Just "ar\n"
--   </pre>
fillIt :: r -> (Delta -> ByteString -> r) -> Delta -> It Rope r

-- | Return the text of the line that contains a given position
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let secondLine = rewindIt (delta ("foo\nb" :: Strict.ByteString))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract secondLine
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo"))
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo\nbar"))
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo\nbar\nbaz"))
--   Just "bar\n"
--   </pre>
rewindIt :: Delta -> It Rope (Maybe ByteString)

-- | Return the text between two offsets.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let secondLine = sliceIt (delta ("foo\n" :: Strict.ByteString)) (delta ("foo\nbar\n" :: Strict.ByteString))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract secondLine
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo"))
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo\nbar"))
--   "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract (simplifyIt secondLine (ropeBS "foo\nbar\nbaz"))
--   "bar\n"
--   </pre>
sliceIt :: Delta -> Delta -> It Rope ByteString
instance GHC.Show.Show a => GHC.Show.Show (Text.Trifecta.Util.It.It r a)
instance GHC.Base.Functor (Text.Trifecta.Util.It.It r)
instance Data.Profunctor.Unsafe.Profunctor Text.Trifecta.Util.It.It
instance GHC.Base.Applicative (Text.Trifecta.Util.It.It r)
instance GHC.Base.Monad (Text.Trifecta.Util.It.It r)
instance Control.Comonad.ComonadApply (Text.Trifecta.Util.It.It r)
instance Control.Comonad.Comonad (Text.Trifecta.Util.It.It r)


-- | The type for Lines will very likely change over time, to enable
--   drawing lit up multi-character versions of control characters for
--   <tt>^Z</tt>, <tt>^[</tt>, <tt><a>0xff</a></tt>, etc. This will make
--   for much nicer diagnostics when working with protocols.
module Text.Trifecta.Rendering

-- | A <a>Rendering</a> is a canvas of text that output can be written to.
data Rendering
Rendering :: !Delta -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> (Lines -> Lines) -> (Delta -> Lines -> Lines) -> Rendering
class HasRendering c_ascd
rendering :: HasRendering c_ascd => Lens' c_ascd Rendering
renderingDelta :: HasRendering c_ascd => Lens' c_ascd Delta
renderingLine :: HasRendering c_ascd => Lens' c_ascd (Lines -> Lines)
renderingLineBytes :: HasRendering c_ascd => Lens' c_ascd Int64
renderingLineLen :: HasRendering c_ascd => Lens' c_ascd Int64
renderingOverlays :: HasRendering c_ascd => Lens' c_ascd (Delta -> Lines -> Lines)

-- | Is the <a>Rendering</a> empty?
--   
--   <pre>
--   &gt;&gt;&gt; nullRendering emptyRendering
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullRendering exampleRendering
--   False
--   </pre>
nullRendering :: Rendering -> Bool

-- | The empty <a>Rendering</a>, which contains nothing at all.
--   
--   <pre>
--   &gt;&gt;&gt; show (prettyRendering emptyRendering)
--   ""
--   </pre>
emptyRendering :: Rendering
prettyRendering :: Rendering -> Doc AnsiStyle
class Source t

-- | <pre>
--   ( Number of (padded) columns
--   , number of bytes
--   , line )
--   </pre>
source :: Source t => t -> (Int64, Int64, Lines -> Lines)

-- | create a drawing surface
rendered :: Source s => Delta -> s -> Rendering
class Renderable t
render :: Renderable t => t -> Rendering
data Rendered a
(:@) :: a -> Rendering -> Rendered a

-- | ANSI terminal style for rendering the gutter.
gutterEffects :: [SGR]

-- | A <a>Caret</a> marks a point in the input with a simple <tt>^</tt>
--   character.
--   
--   <pre>
--   &gt;&gt;&gt; unAnnotate (prettyRendering (addCaret (Columns 35 35) exampleRendering))
--   1 | int main(int argc, char ** argv) { int; }&lt;EOF&gt;
--     |                                    ^
--   </pre>
data Caret
Caret :: !Delta -> {-# UNPACK #-} !ByteString -> Caret
class HasCaret t
caret :: HasCaret t => Lens' t Caret
data Careted a
(:^) :: a -> Caret -> Careted a
drawCaret :: Delta -> Delta -> Lines -> Lines

-- | Render a caret at a certain position in a <a>Rendering</a>.
addCaret :: Delta -> Rendering -> Rendering

-- | ANSI terminal style for rendering the caret.
caretEffects :: [SGR]
renderingCaret :: Delta -> ByteString -> Rendering

-- | A <a>Span</a> marks a range of input characters. If <a>Caret</a> is a
--   point, then <a>Span</a> is a line.
--   
--   <pre>
--   &gt;&gt;&gt; unAnnotate (prettyRendering (addSpan (Columns 35 35) (Columns 38 38) exampleRendering))
--   1 | int main(int argc, char ** argv) { int; }&lt;EOF&gt;
--     |                                    ~~~
--   </pre>
data Span
Span :: !Delta -> !Delta -> {-# UNPACK #-} !ByteString -> Span
class HasSpan t
span :: HasSpan t => Lens' t Span

-- | Annotate an arbitrary piece of data with a <a>Span</a>, typically its
--   corresponding input location.
data Spanned a
(:~) :: a -> Span -> Spanned a

-- | ANSI terminal style to render spans with.
spanEffects :: [SGR]
drawSpan :: Delta -> Delta -> Delta -> Lines -> Lines
addSpan :: Delta -> Delta -> Rendering -> Rendering

-- | A <a>Fixit</a> is a <a>Span</a> with a suggestion.
--   
--   <pre>
--   &gt;&gt;&gt; unAnnotate (prettyRendering (addFixit (Columns 35 35) (Columns 38 38) "Fix this!" exampleRendering))
--   1 | int main(int argc, char ** argv) { int; }&lt;EOF&gt;
--     |                                    ~~~
--     |                                    Fix this!
--   </pre>
data Fixit
Fixit :: {-# UNPACK #-} !Span -> !ByteString -> Fixit

-- | <a>Span</a> where the error occurred
[_fixitSpan] :: Fixit -> {-# UNPACK #-} !Span

-- | Replacement suggestion
[_fixitReplacement] :: Fixit -> !ByteString
class HasFixit c_auer
fixit :: HasFixit c_auer => Lens' c_auer Fixit
fixitReplacement :: HasFixit c_auer => Lens' c_auer ByteString
fixitSpan :: HasFixit c_auer => Lens' c_auer Span
drawFixit :: Delta -> Delta -> String -> Delta -> Lines -> Lines
addFixit :: Delta -> Delta -> String -> Rendering -> Rendering

-- | A raw canvas to paint ANSI-styled characters on.
type Lines = Array (Int, Int64) ([SGR], Char)
draw :: [SGR] -> Int -> Int64 -> String -> Lines -> Lines
ifNear :: Delta -> (Lines -> Lines) -> Delta -> Lines -> Lines
(.#) :: (Delta -> Lines -> Lines) -> Rendering -> Rendering
instance Text.Trifecta.Rendering.HasFixit Text.Trifecta.Rendering.Fixit
instance Text.Trifecta.Rendering.HasSpan Text.Trifecta.Rendering.Fixit
instance Data.Hashable.Class.Hashable Text.Trifecta.Rendering.Fixit
instance Data.Semigroup.Reducer.Reducer Text.Trifecta.Rendering.Fixit Text.Trifecta.Rendering.Rendering
instance Text.Trifecta.Rendering.Renderable Text.Trifecta.Rendering.Fixit
instance GHC.Show.Show a => GHC.Show.Show (Text.Trifecta.Rendering.Rendered a)
instance GHC.Generics.Generic Text.Trifecta.Rendering.Caret
instance Data.Data.Data Text.Trifecta.Rendering.Caret
instance GHC.Show.Show Text.Trifecta.Rendering.Caret
instance GHC.Classes.Ord Text.Trifecta.Rendering.Caret
instance GHC.Classes.Eq Text.Trifecta.Rendering.Caret
instance GHC.Generics.Generic (Text.Trifecta.Rendering.Careted a)
instance Data.Data.Data a => Data.Data.Data (Text.Trifecta.Rendering.Careted a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Trifecta.Rendering.Careted a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Text.Trifecta.Rendering.Careted a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Trifecta.Rendering.Careted a)
instance GHC.Generics.Generic Text.Trifecta.Rendering.Span
instance Data.Data.Data Text.Trifecta.Rendering.Span
instance GHC.Show.Show Text.Trifecta.Rendering.Span
instance GHC.Classes.Ord Text.Trifecta.Rendering.Span
instance GHC.Classes.Eq Text.Trifecta.Rendering.Span
instance GHC.Generics.Generic (Text.Trifecta.Rendering.Spanned a)
instance Data.Data.Data a => Data.Data.Data (Text.Trifecta.Rendering.Spanned a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Trifecta.Rendering.Spanned a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Text.Trifecta.Rendering.Spanned a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Trifecta.Rendering.Spanned a)
instance GHC.Generics.Generic Text.Trifecta.Rendering.Fixit
instance Data.Data.Data Text.Trifecta.Rendering.Fixit
instance GHC.Show.Show Text.Trifecta.Rendering.Fixit
instance GHC.Classes.Ord Text.Trifecta.Rendering.Fixit
instance GHC.Classes.Eq Text.Trifecta.Rendering.Fixit
instance Text.Trifecta.Rendering.HasSpan (Text.Trifecta.Rendering.Spanned a)
instance GHC.Base.Functor Text.Trifecta.Rendering.Spanned
instance Control.Comonad.Comonad Text.Trifecta.Rendering.Spanned
instance Control.Comonad.ComonadApply Text.Trifecta.Rendering.Spanned
instance Data.Foldable.Foldable Text.Trifecta.Rendering.Spanned
instance Data.Traversable.Traversable Text.Trifecta.Rendering.Spanned
instance Data.Semigroup.Reducer.Reducer (Text.Trifecta.Rendering.Spanned a) Text.Trifecta.Rendering.Rendering
instance Text.Trifecta.Rendering.Renderable (Text.Trifecta.Rendering.Spanned a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Text.Trifecta.Rendering.Spanned a)
instance Text.Trifecta.Rendering.HasSpan Text.Trifecta.Rendering.Span
instance Text.Trifecta.Rendering.Renderable Text.Trifecta.Rendering.Span
instance GHC.Base.Semigroup Text.Trifecta.Rendering.Span
instance Data.Semigroup.Reducer.Reducer Text.Trifecta.Rendering.Span Text.Trifecta.Rendering.Rendering
instance Data.Hashable.Class.Hashable Text.Trifecta.Rendering.Span
instance Text.Trifecta.Rendering.HasCaret (Text.Trifecta.Rendering.Careted a)
instance GHC.Base.Functor Text.Trifecta.Rendering.Careted
instance Text.Trifecta.Delta.HasDelta (Text.Trifecta.Rendering.Careted a)
instance Text.Trifecta.Delta.HasBytes (Text.Trifecta.Rendering.Careted a)
instance Control.Comonad.Comonad Text.Trifecta.Rendering.Careted
instance Control.Comonad.ComonadApply Text.Trifecta.Rendering.Careted
instance Data.Foldable.Foldable Text.Trifecta.Rendering.Careted
instance Data.Traversable.Traversable Text.Trifecta.Rendering.Careted
instance Text.Trifecta.Rendering.Renderable (Text.Trifecta.Rendering.Careted a)
instance Data.Semigroup.Reducer.Reducer (Text.Trifecta.Rendering.Careted a) Text.Trifecta.Rendering.Rendering
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Text.Trifecta.Rendering.Careted a)
instance Text.Trifecta.Rendering.HasCaret Text.Trifecta.Rendering.Caret
instance Data.Hashable.Class.Hashable Text.Trifecta.Rendering.Caret
instance Text.Trifecta.Delta.HasBytes Text.Trifecta.Rendering.Caret
instance Text.Trifecta.Delta.HasDelta Text.Trifecta.Rendering.Caret
instance Text.Trifecta.Rendering.Renderable Text.Trifecta.Rendering.Caret
instance Data.Semigroup.Reducer.Reducer Text.Trifecta.Rendering.Caret Text.Trifecta.Rendering.Rendering
instance GHC.Base.Semigroup Text.Trifecta.Rendering.Caret
instance GHC.Base.Functor Text.Trifecta.Rendering.Rendered
instance Text.Trifecta.Delta.HasDelta (Text.Trifecta.Rendering.Rendered a)
instance Text.Trifecta.Delta.HasBytes (Text.Trifecta.Rendering.Rendered a)
instance Control.Comonad.Comonad Text.Trifecta.Rendering.Rendered
instance Control.Comonad.ComonadApply Text.Trifecta.Rendering.Rendered
instance Data.Foldable.Foldable Text.Trifecta.Rendering.Rendered
instance Data.Traversable.Traversable Text.Trifecta.Rendering.Rendered
instance Text.Trifecta.Rendering.Renderable (Text.Trifecta.Rendering.Rendered a)
instance Text.Trifecta.Rendering.Source GHC.Base.String
instance Text.Trifecta.Rendering.Source Data.ByteString.Internal.ByteString
instance Text.Trifecta.Rendering.Renderable Text.Trifecta.Rendering.Rendering
instance Text.Trifecta.Rendering.HasRendering Text.Trifecta.Rendering.Rendering
instance GHC.Show.Show Text.Trifecta.Rendering.Rendering
instance GHC.Base.Semigroup Text.Trifecta.Rendering.Rendering
instance GHC.Base.Monoid Text.Trifecta.Rendering.Rendering
instance Text.Trifecta.Delta.HasDelta Text.Trifecta.Rendering.Rendering


-- | Results and Parse Errors
module Text.Trifecta.Result

-- | The result of parsing. Either we succeeded or something went wrong.
data Result a
Success :: a -> Result a
Failure :: ErrInfo -> Result a

-- | A <a>Prism</a> that lets you embed or retrieve a <a>Result</a> in a
--   potentially larger type.
class AsResult s t a b | s -> a, t -> b, s b -> t, t a -> s
_Result :: AsResult s t a b => Prism s t (Result a) (Result b)

-- | Fold over a <a>Result</a>
foldResult :: (ErrInfo -> b) -> (a -> b) -> Result a -> b

-- | The <a>Prism</a> for the <a>Success</a> constructor of <a>Result</a>
_Success :: AsResult s t a b => Prism s t a b

-- | The <a>Prism</a> for the <a>Failure</a> constructor of <a>Result</a>
_Failure :: AsResult s s a a => Prism' s ErrInfo

-- | This is used to report an error. What went wrong, some supplemental
--   docs and a set of things expected at the current location. This does
--   not, however, include the actual location.
data Err
Err :: Maybe (Doc AnsiStyle) -> [Doc AnsiStyle] -> Set String -> [Delta] -> Err
[_reason] :: Err -> Maybe (Doc AnsiStyle)
[_footnotes] :: Err -> [Doc AnsiStyle]
[_expected] :: Err -> Set String
[_finalDeltas] :: Err -> [Delta]
class HasErr c_aEgX
err :: HasErr c_aEgX => Lens' c_aEgX Err
expected :: HasErr c_aEgX => Lens' c_aEgX (Set String)
finalDeltas :: HasErr c_aEgX => Lens' c_aEgX [Delta]
footnotes :: HasErr c_aEgX => Lens' c_aEgX [Doc AnsiStyle]
reason :: HasErr c_aEgX => Lens' c_aEgX (Maybe (Doc AnsiStyle))
class Errable m
raiseErr :: Errable m => Err -> m a
data ErrInfo
ErrInfo :: Doc AnsiStyle -> [Delta] -> ErrInfo
[_errDoc] :: ErrInfo -> Doc AnsiStyle
[_errDeltas] :: ErrInfo -> [Delta]

-- | Convert a <a>Rendering</a> of auxiliary information and an <a>Err</a>
--   into a 'Doc AnsiStyle', ready to be prettyprinted to the user.
explain :: Rendering -> Err -> Doc AnsiStyle

-- | Generate a simple <a>Err</a> word-wrapping the supplied message.
failed :: String -> Err
instance Data.Traversable.Traversable Text.Trifecta.Result.Result
instance Data.Foldable.Foldable Text.Trifecta.Result.Result
instance GHC.Base.Functor Text.Trifecta.Result.Result
instance GHC.Show.Show a => GHC.Show.Show (Text.Trifecta.Result.Result a)
instance Text.Trifecta.Result.AsResult (Text.Trifecta.Result.Result a) (Text.Trifecta.Result.Result b) a b
instance GHC.Base.Applicative Text.Trifecta.Result.Result
instance GHC.Base.Alternative Text.Trifecta.Result.Result
instance GHC.Base.Monad Text.Trifecta.Result.Result
instance Text.Trifecta.Result.HasErr Text.Trifecta.Result.Err
instance GHC.Base.Semigroup Text.Trifecta.Result.Err
instance GHC.Base.Monoid Text.Trifecta.Result.Err
instance GHC.Base.Monoid Text.Trifecta.Result.ErrInfo
instance GHC.Base.Semigroup Text.Trifecta.Result.ErrInfo
instance GHC.Show.Show Text.Trifecta.Result.ErrInfo


module Text.Trifecta.Highlight

-- | Tags used by the <a>TokenParsing</a> <a>highlight</a> combinator.
data Highlight

-- | A <a>HighlightedRope</a> is a <a>Rope</a> with an associated
--   <a>IntervalMap</a> full of highlighted regions.
data HighlightedRope
HighlightedRope :: !IntervalMap Delta Highlight -> {-# UNPACK #-} !Rope -> HighlightedRope
class HasHighlightedRope c_aHb8
highlightedRope :: HasHighlightedRope c_aHb8 => Lens' c_aHb8 HighlightedRope
ropeContent :: HasHighlightedRope c_aHb8 => Lens' c_aHb8 Rope
ropeHighlights :: HasHighlightedRope c_aHb8 => Lens' c_aHb8 (IntervalMap Delta Highlight)

-- | Convert a <a>Highlight</a> into a coloration on a <a>Doc</a>.
withHighlight :: Highlight -> Doc AnsiStyle -> Doc AnsiStyle

-- | Represents a source file like an HsColour rendered document
data HighlightDoc
HighlightDoc :: String -> String -> HighlightedRope -> HighlightDoc
class HasHighlightDoc c_aHm3
highlightDoc :: HasHighlightDoc c_aHm3 => Lens' c_aHm3 HighlightDoc
docContent :: HasHighlightDoc c_aHm3 => Lens' c_aHm3 HighlightedRope
docCss :: HasHighlightDoc c_aHm3 => Lens' c_aHm3 String
docTitle :: HasHighlightDoc c_aHm3 => Lens' c_aHm3 String

-- | Generate an HTML document from a title and a <a>HighlightedRope</a>.
doc :: String -> HighlightedRope -> HighlightDoc
instance Text.Trifecta.Highlight.HasHighlightDoc Text.Trifecta.Highlight.HighlightDoc
instance Text.Blaze.ToMarkup Text.Trifecta.Highlight.HighlightDoc
instance GHC.Classes.Eq (Text.Trifecta.Highlight.Located a)
instance GHC.Classes.Ord (Text.Trifecta.Highlight.Located a)
instance Text.Blaze.ToMarkup Text.Trifecta.Highlight.HighlightedRope
instance Text.Trifecta.Highlight.HasHighlightedRope Text.Trifecta.Highlight.HighlightedRope
instance Text.Trifecta.Delta.HasDelta Text.Trifecta.Highlight.HighlightedRope
instance Text.Trifecta.Delta.HasBytes Text.Trifecta.Highlight.HighlightedRope
instance GHC.Base.Semigroup Text.Trifecta.Highlight.HighlightedRope
instance GHC.Base.Monoid Text.Trifecta.Highlight.HighlightedRope


module Text.Trifecta.Combinators

-- | This class provides parsers with easy access to:
--   
--   1) the current line contents. 2) the current position as a
--   <a>Delta</a>. 3) the ability to use <a>sliced</a> on any parser.
class (MonadPlus m, TokenParsing m) => DeltaParsing m

-- | Retrieve the contents of the current line (from the beginning of the
--   line)
line :: DeltaParsing m => m ByteString

-- | Retrieve the current position as a <a>Delta</a>.
position :: DeltaParsing m => m Delta

-- | Run a parser, grabbing all of the text between its start and end
--   points
slicedWith :: DeltaParsing m => (a -> ByteString -> r) -> m a -> m r

-- | Retrieve a <a>Rendering</a> of the current line noting this position,
--   but not placing a <a>Caret</a> there.
rend :: DeltaParsing m => m Rendering

-- | Grab the remainder of the current line
restOfLine :: DeltaParsing m => m ByteString

-- | Run a parser, grabbing all of the text between its start and end
--   points and discarding the original result
sliced :: DeltaParsing m => m a -> m ByteString

-- | Grab a <a>Caret</a> pointing to the current location.
careting :: DeltaParsing m => m Caret

-- | Parse a <a>Careted</a> result. Pointing the <a>Caret</a> to where you
--   start.
careted :: DeltaParsing m => m a -> m (Careted a)

-- | Discard the result of a parse, returning a <a>Span</a> from where we
--   start to where it ended parsing.
spanning :: DeltaParsing m => m a -> m Span

-- | Parse a <a>Spanned</a> result. The <a>Span</a> starts here and runs to
--   the last position parsed.
spanned :: DeltaParsing m => m a -> m (Spanned a)

-- | Grab a fixit.
fixiting :: DeltaParsing m => m ByteString -> m Fixit

-- | This class is a refinement of <a>DeltaParsing</a> that adds the
--   ability to mark your position in the input and return there for
--   further parsing later.
class (DeltaParsing m, HasDelta d) => MarkParsing d m | m -> d

-- | mark the current location so it can be used in constructing a span, or
--   for later seeking
mark :: MarkParsing d m => m d

-- | Seek a previously marked location
release :: MarkParsing d m => d -> m ()
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.Reader.ReaderT e m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.MarkParsing d m) => Text.Trifecta.Combinators.MarkParsing d (Control.Monad.Trans.Identity.IdentityT m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.Reader.ReaderT e m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m, GHC.Base.Monoid w) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.MonadPlus m, Text.Trifecta.Combinators.DeltaParsing m) => Text.Trifecta.Combinators.DeltaParsing (Control.Monad.Trans.Identity.IdentityT m)


module Text.Trifecta.Parser

-- | The type of a trifecta parser
--   
--   The first four arguments are behavior continuations:
--   
--   <ul>
--   <li>epsilon success: the parser has consumed no input and has a result
--   as well as a possible Err; the position and chunk are unchanged (see
--   <a>pure</a>)</li>
--   <li>epsilon failure: the parser has consumed no input and is failing
--   with the given Err; the position and chunk are unchanged (see
--   <a>empty</a>)</li>
--   <li>committed success: the parser has consumed input and is yielding
--   the result, set of expected strings that would have permitted this
--   parse to continue, new position, and residual chunk to the
--   continuation.</li>
--   <li>committed failure: the parser has consumed input and is failing
--   with a given ErrInfo (user-facing error message)</li>
--   </ul>
--   
--   The remaining two arguments are
--   
--   <ul>
--   <li>the current position</li>
--   <li>the chunk of input currently under analysis</li>
--   </ul>
--   
--   <a>Parser</a> is an <a>Alternative</a>; trifecta's backtracking
--   behavior encoded as <a>&lt;|&gt;</a> is to behave as the leftmost
--   parser which yields a value (regardless of any input being consumed)
--   or which consumes input and fails. That is, a choice of parsers will
--   only yield an epsilon failure if *all* parsers in the choice do. If
--   that is not the desired behavior, see <a>try</a>, which turns a
--   committed parser failure into an epsilon failure (at the cost of error
--   information).
newtype Parser a
Parser :: (forall r. (a -> Err -> It Rope r) -> (Err -> It Rope r) -> (a -> Set String -> Delta -> ByteString -> It Rope r) -> (ErrInfo -> It Rope r) -> Delta -> ByteString -> It Rope r) -> Parser a
[unparser] :: Parser a -> forall r. (a -> Err -> It Rope r) -> (Err -> It Rope r) -> (a -> Set String -> Delta -> ByteString -> It Rope r) -> (ErrInfo -> It Rope r) -> Delta -> ByteString -> It Rope r
manyAccum :: (a -> [a] -> [a]) -> Parser a -> Parser [a]

-- | A <a>Step</a> allows for incremental parsing, since the parser
--   
--   <ul>
--   <li>can be done with a final result</li>
--   <li>have errored</li>
--   <li>can have yielded a partial result with possibly more to come</li>
--   </ul>
data Step a

-- | Parsing is done and has converted the <a>Rope</a> to a final result
StepDone :: !Rope -> a -> Step a

-- | Parsing the <a>Rope</a> has failed with an error
StepFail :: !Rope -> ErrInfo -> Step a

-- | The <a>Rope</a> has been partially consumed and already yielded a
--   <a>Result</a>, and if more input is provided, more results can be
--   produced.
--   
--   One common scenario for this is to parse log files: after parsing a
--   single line, that data can already be worked with, but there may be
--   more lines to come.
StepCont :: !Rope -> Result a -> (Rope -> Step a) -> Step a

-- | Feed some additional input to a <a>Step</a> to continue parsing a bit
--   further.
feed :: Reducer t Rope => t -> Step r -> Step r

-- | Assume all possible input has been given to the parser, execute it to
--   yield a final result.
starve :: Step a -> Result a

-- | Incremental parsing. A <a>Step</a> can be supplied with new input
--   using <a>feed</a>, the final <a>Result</a> is obtained using
--   <a>starve</a>.
stepParser :: Parser a -> Delta -> Step a
stepResult :: Rope -> Result a -> Step a
stepIt :: It Rope a -> Step a

-- | Run a <a>Parser</a> on input that can be reduced to a <a>Rope</a>,
--   e.g. <a>String</a>, or <a>ByteString</a>. See also the monomorphic
--   versions <a>parseString</a> and <a>parseByteString</a>.
runParser :: Reducer t Rope => Parser a -> Delta -> t -> Result a

-- | <tt>(<a>parseFromFile</a> p filePath)</tt> runs a parser <tt>p</tt> on
--   the input read from <tt>filePath</tt> using <a>readFile</a>. All
--   diagnostic messages emitted over the course of the parse attempt are
--   shown to the user on the console.
--   
--   <pre>
--   main = do
--     result &lt;- parseFromFile numbers "digits.txt"
--     case result of
--       Nothing -&gt; return ()
--       Just a  -&gt; print $ sum a
--   </pre>
parseFromFile :: MonadIO m => Parser a -> String -> m (Maybe a)

-- | <tt>(<a>parseFromFileEx</a> p filePath)</tt> runs a parser <tt>p</tt>
--   on the input read from <tt>filePath</tt> using <a>readFile</a>.
--   Returns all diagnostic messages emitted over the course of the parse
--   and the answer if the parse was successful.
--   
--   <pre>
--   main = do
--     result &lt;- parseFromFileEx (many number) "digits.txt"
--     case result of
--       Failure xs -&gt; displayLn xs
--       Success a  -&gt; print (sum a)
--   </pre>
parseFromFileEx :: MonadIO m => Parser a -> String -> m (Result a)

-- | Fully parse a <a>String</a> to a <a>Result</a>.
--   
--   <tt>parseByteString p delta i</tt> runs a parser <tt>p</tt> on
--   <tt>i</tt>.
parseString :: Parser a -> Delta -> String -> Result a

-- | Fully parse a <a>ByteString</a> to a <a>Result</a>.
--   
--   <tt>parseByteString p delta i</tt> runs a parser <tt>p</tt> on
--   <tt>i</tt>.
parseByteString :: Parser a -> Delta -> ByteString -> Result a
parseTest :: (MonadIO m, Show a) => Parser a -> String -> m ()
instance GHC.Show.Show a => GHC.Show.Show (Text.Trifecta.Parser.Step a)
instance GHC.Base.Functor Text.Trifecta.Parser.Step
instance GHC.Base.Functor Text.Trifecta.Parser.Parser
instance GHC.Base.Applicative Text.Trifecta.Parser.Parser
instance GHC.Base.Alternative Text.Trifecta.Parser.Parser
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Text.Trifecta.Parser.Parser a)
instance (GHC.Base.Semigroup a, GHC.Base.Monoid a) => GHC.Base.Monoid (Text.Trifecta.Parser.Parser a)
instance GHC.Base.Monad Text.Trifecta.Parser.Parser
instance Control.Monad.Fail.MonadFail Text.Trifecta.Parser.Parser
instance GHC.Base.MonadPlus Text.Trifecta.Parser.Parser
instance Text.Parser.Combinators.Parsing Text.Trifecta.Parser.Parser
instance Text.Trifecta.Result.Errable Text.Trifecta.Parser.Parser
instance Text.Parser.LookAhead.LookAheadParsing Text.Trifecta.Parser.Parser
instance Text.Parser.Char.CharParsing Text.Trifecta.Parser.Parser
instance Text.Parser.Token.TokenParsing Text.Trifecta.Parser.Parser
instance Text.Trifecta.Combinators.DeltaParsing Text.Trifecta.Parser.Parser
instance Text.Trifecta.Combinators.MarkParsing Text.Trifecta.Delta.Delta Text.Trifecta.Parser.Parser


-- | For a short introduction, see the <a>Text.Trifecta.Tutorial</a>
--   module.
module Text.Trifecta


-- | This module provides a short introduction to get users started using
--   Trifecta. The key takeaway message is that it’s not harder, or even
--   much different, from using other parser libraries, so for users
--   familiar with one of the many Parsecs should feel right at home.
--   
--   <b>The source of this file is written in a literate style</b>, and can
--   be read top-to-bottom.
module Text.Trifecta.Tutorial

-- | First, we import Trifecta itself. It only the core parser definitions
--   and instances. Since Trifecta on its own is just the parser and a
--   handful of instances; the bulk of the utility functions is actually
--   from a separate package, <i>parsers</i>, that provides the usual
--   parsing functions like <a>manyTill</a>, <a>between</a>, and so on. The
--   idea behind the <i>parsers</i> package is that most parser libraries
--   define the same generic functions, so they were put into their own
--   package to be shared. Trifecta reexports these definitions, but it’s
--   useful to keep in mind that the documentation of certain functions
--   might not be directly in the <i>trifecta</i> package.
importDocumentation :: docDummy

-- | In order to keep things minimal, we define a very simple language for
--   arithmetic expressions.
data Expr

-- | expr + expr
Add :: Expr -> Expr -> Expr

-- | 1, 2, -345, …
Lit :: Integer -> Expr

-- | The parser is straightforward: there are literal integers, and
--   parenthesized additions. We require parentheses in order to keep the
--   example super simple as to not worry about operator precedence.
--   
--   It is useful to use <i>tokenizing</i> functions to write parsers.
--   Roughly speaking, these automatically skip trailing whitespace on
--   their own, so that the parser isn’t cluttered with
--   <tt>skipWhitespace</tt> calls. <a>symbolic</a> for example parses a
--   <a>Char</a> and then skips trailing whitespace; there is also the more
--   primitive <a>char</a> function that just parses its argument and
--   nothing else.
parseExpr :: Parser Expr

-- | We can now use our parser to convert a <a>String</a> to an
--   <a>Expr</a>,
--   
--   <pre>
--   parseString parseExpr mempty "(1 + (2 + 3))"
--   </pre>
--   
--   <pre>
--   Success (Add (Lit 1) (Add (Lit 2) (Lit 3)))
--   </pre>
--   
--   When we provide ill-formed input, we get a nice error message with an
--   arrow to the location where the error occurred:
--   
--   <pre>
--   parseString parseExpr mempty "(1 + 2 + 3))"
--   </pre>
--   
--   <pre>
--   (interactive):1:8: error: expected: ")"
--   1 | (1 + 2 + 3))&lt;EOF&gt;
--     |        ^
--   </pre>
examples :: docDummy
instance GHC.Show.Show Text.Trifecta.Tutorial.Expr
