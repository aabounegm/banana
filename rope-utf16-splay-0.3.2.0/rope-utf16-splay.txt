-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Ropes optimised for updating using UTF-16 code units and
--   row/column pairs.
--   
--   Ropes optimised for updating using UTF-16 code units and row/column
--   pairs. This implementation uses splay trees instead of the usual
--   finger trees. According to my benchmarks, splay trees are faster in
--   most situations.
@package rope-utf16-splay
@version 0.3.2.0

module Data.Rope.UTF16.Internal.Position
data RowColumn
RowColumn :: !Int -> !Int -> RowColumn

-- | Number of newlines before this position
[row] :: RowColumn -> !Int

-- | Number of code units since last newline or start of string
[column] :: RowColumn -> !Int
data Position
Position :: !Int -> !RowColumn -> Position
[codeUnits] :: Position -> !Int
[rowColumn] :: Position -> !RowColumn
instance GHC.Show.Show Data.Rope.UTF16.Internal.Position.RowColumn
instance GHC.Classes.Ord Data.Rope.UTF16.Internal.Position.RowColumn
instance GHC.Classes.Eq Data.Rope.UTF16.Internal.Position.RowColumn
instance GHC.Show.Show Data.Rope.UTF16.Internal.Position.Position
instance GHC.Classes.Ord Data.Rope.UTF16.Internal.Position.Position
instance GHC.Classes.Eq Data.Rope.UTF16.Internal.Position.Position
instance GHC.Base.Semigroup Data.Rope.UTF16.Internal.Position.Position
instance GHC.Base.Monoid Data.Rope.UTF16.Internal.Position.Position
instance GHC.Base.Semigroup Data.Rope.UTF16.Internal.Position.RowColumn
instance GHC.Base.Monoid Data.Rope.UTF16.Internal.Position.RowColumn


-- | Helpers for working with <a>Text</a> in UTF-16 code units
module Data.Rope.UTF16.Internal.Text
clamp16 :: Int -> Text -> Int
take16 :: Int -> Text -> Text
drop16 :: Int -> Text -> Text
split16At :: Int -> Text -> (Text, Text)
chunks16Of :: Int -> Text -> [Text]

module Data.SplayTree
class Monoid v => Measured v a | a -> v
measure :: Measured v a => a -> v
data SplayTree v a
Leaf :: SplayTree v a

-- | Cached measure of the whole node
Fork :: SplayTree v a -> a -> SplayTree v a -> !v -> SplayTree v a

-- | Is the splay tree empty?
null :: SplayTree v a -> Bool
singleton :: Measured v a => a -> SplayTree v a
(<|) :: Measured v a => a -> SplayTree v a -> SplayTree v a
infixr 5 <|
(|>) :: Measured v a => SplayTree v a -> a -> SplayTree v a
infixl 5 |>
fork :: Measured v a => SplayTree v a -> a -> SplayTree v a -> SplayTree v a
uncons :: Measured v a => SplayTree v a -> Maybe (a, SplayTree v a)
unsnoc :: Measured v a => SplayTree v a -> Maybe (SplayTree v a, a)
data SplitResult v a
Outside :: SplitResult v a
Inside :: SplayTree v a -> a -> SplayTree v a -> SplitResult v a
split :: Measured v a => (v -> Bool) -> SplayTree v a -> SplitResult v a
map :: (Measured v a, Measured w b) => (a -> b) -> SplayTree v a -> SplayTree w b
mapWithPos :: (Measured v a, Measured w b) => (v -> a -> b) -> SplayTree v a -> SplayTree w b
mapWithContext :: (Measured v a, Measured w b) => (v -> a -> v -> b) -> SplayTree v a -> SplayTree w b
traverse :: (Measured v a, Measured w b, Applicative f) => (a -> f b) -> SplayTree v a -> f (SplayTree w b)
traverseWithPos :: (Measured v a, Measured w b, Applicative f) => (v -> a -> f b) -> SplayTree v a -> f (SplayTree w b)
traverseWithContext :: (Measured v a, Measured w b, Applicative f) => (v -> a -> v -> f b) -> SplayTree v a -> f (SplayTree w b)
instance Data.Foldable.Foldable (Data.SplayTree.SplayTree v)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Data.SplayTree.SplayTree v a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.SplayTree.SplayTree v a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.SplayTree.SplayTree v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Data.SplayTree.SplitResult v a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.SplayTree.SplitResult v a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.SplayTree.SplitResult v a)
instance Data.SplayTree.Measured v a => Data.SplayTree.Measured v (Data.SplayTree.SplayTree v a)
instance Data.SplayTree.Measured v a => GHC.Base.Semigroup (Data.SplayTree.SplayTree v a)
instance Data.SplayTree.Measured v a => GHC.Base.Monoid (Data.SplayTree.SplayTree v a)

module Data.Rope.UTF16.Internal
data Chunk
Chunk :: !Text -> !Position -> Chunk
[chunkText] :: Chunk -> !Text
[chunkMeasure] :: Chunk -> !Position
chunk :: Text -> Chunk

-- | A <a>SplayTree</a> of <a>Text</a> values optimised for being indexed
--   by and modified at UTF-16 code units and row/column (<a>RowColumn</a>)
--   positions. Internal invariant: No empty <a>Chunk</a>s in the
--   <a>SplayTree</a>
newtype Rope
Rope :: SplayTree Position Chunk -> Rope
[unrope] :: Rope -> SplayTree Position Chunk

-- | The maximum length, in code units, of a chunk
chunkLength :: Int

-- | Is the rope empty?
null :: Rope -> Bool

-- | Length in code units (not characters)
length :: Rope -> Int

-- | The number of newlines in the rope
rows :: Rope -> Int

-- | The number of code units (not characters) since the last newline or
--   the start of the rope
columns :: Rope -> Int
toText :: Rope -> Text
toLazyText :: Rope -> Text
fromText :: Text -> Rope
fromShortText :: Text -> Rope
toString :: Rope -> String

-- | Map over the characters of a rope
map :: (Char -> Char) -> Rope -> Rope

-- | Concatenate the interspersion of a rope between the elements of a list
--   of ropes
intercalate :: Rope -> [Rope] -> Rope

-- | The raw <a>Text</a> data that the <a>Rope</a> is built from
toChunks :: Rope -> [Text]

-- | Get the first chunk and the rest of the <a>Rope</a> if non-empty
unconsChunk :: Rope -> Maybe (Text, Rope)

-- | Get the last chunk and the rest of the <a>Rope</a> if non-empty
unsnocChunk :: Rope -> Maybe (Rope, Text)

-- | Split the rope at the nth code unit (not character)
splitAt :: Int -> Rope -> (Rope, Rope)

-- | Take the first n code units (not characters)
take :: Int -> Rope -> Rope

-- | Drop the first n code units (not characters)
drop :: Int -> Rope -> Rope

-- | Get the code unit index in the rope that corresponds to a
--   <a>RowColumn</a> position
rowColumnCodeUnits :: RowColumn -> Rope -> Int

-- | Get the <a>RowColumn</a> position that corresponds to a code unit
--   index in the rope
codeUnitsRowColumn :: Int -> Rope -> RowColumn

-- | Split the rope immediately after the i:th newline
splitAtLine :: Int -> Rope -> (Rope, Rope)

-- | <pre>
--   span f r = (takeWhile f r, dropWhile f r)
--   </pre>
span :: (Char -> Bool) -> Rope -> (Rope, Rope)

-- | <pre>
--   break f = span (not . f)
--   </pre>
break :: (Char -> Bool) -> Rope -> (Rope, Rope)

-- | <pre>
--   takeWhile f = fst . span f
--   </pre>
takeWhile :: (Char -> Bool) -> Rope -> Rope

-- | <pre>
--   dropWhile f = snd . span f
--   </pre>
dropWhile :: (Char -> Bool) -> Rope -> Rope

-- | Fold left
foldl :: (a -> Char -> a) -> a -> Rope -> a

-- | A strict version of <a>foldl</a>
foldl' :: (a -> Char -> a) -> a -> Rope -> a

-- | Fold right
foldr :: (Char -> a -> a) -> a -> Rope -> a

-- | Do any characters in the rope satisfy the predicate?
any :: (Char -> Bool) -> Rope -> Bool

-- | Do all characters in the rope satisfy the predicate?
all :: (Char -> Bool) -> Rope -> Bool
instance GHC.Show.Show Data.Rope.UTF16.Internal.Rope
instance Data.SplayTree.Measured Data.Rope.UTF16.Internal.Position.Position Data.Rope.UTF16.Internal.Rope
instance GHC.Base.Semigroup Data.Rope.UTF16.Internal.Rope
instance GHC.Base.Monoid Data.Rope.UTF16.Internal.Rope
instance GHC.Classes.Eq Data.Rope.UTF16.Internal.Rope
instance GHC.Classes.Ord Data.Rope.UTF16.Internal.Rope
instance Data.String.IsString Data.Rope.UTF16.Internal.Rope
instance GHC.Show.Show Data.Rope.UTF16.Internal.Chunk
instance GHC.Base.Semigroup Data.Rope.UTF16.Internal.Chunk
instance Data.SplayTree.Measured Data.Rope.UTF16.Internal.Position.Position Data.Rope.UTF16.Internal.Chunk

module Data.Rope.UTF16

-- | A <a>SplayTree</a> of <a>Text</a> values optimised for being indexed
--   by and modified at UTF-16 code units and row/column (<a>RowColumn</a>)
--   positions. Internal invariant: No empty <a>Chunk</a>s in the
--   <a>SplayTree</a>
data Rope

-- | Is the rope empty?
null :: Rope -> Bool

-- | Length in code units (not characters)
length :: Rope -> Int

-- | The number of newlines in the rope
rows :: Rope -> Int

-- | The number of code units (not characters) since the last newline or
--   the start of the rope
columns :: Rope -> Int
toText :: Rope -> Text
toLazyText :: Rope -> Text
fromText :: Text -> Rope
toString :: Rope -> String

-- | Map over the characters of a rope
map :: (Char -> Char) -> Rope -> Rope

-- | Concatenate the interspersion of a rope between the elements of a list
--   of ropes
intercalate :: Rope -> [Rope] -> Rope

-- | The raw <a>Text</a> data that the <a>Rope</a> is built from
toChunks :: Rope -> [Text]

-- | Get the first chunk and the rest of the <a>Rope</a> if non-empty
unconsChunk :: Rope -> Maybe (Text, Rope)

-- | Get the last chunk and the rest of the <a>Rope</a> if non-empty
unsnocChunk :: Rope -> Maybe (Rope, Text)

-- | Split the rope at the nth code unit (not character)
splitAt :: Int -> Rope -> (Rope, Rope)

-- | Take the first n code units (not characters)
take :: Int -> Rope -> Rope

-- | Drop the first n code units (not characters)
drop :: Int -> Rope -> Rope
data RowColumn
RowColumn :: !Int -> !Int -> RowColumn

-- | Number of newlines before this position
[row] :: RowColumn -> !Int

-- | Number of code units since last newline or start of string
[column] :: RowColumn -> !Int

-- | Get the code unit index in the rope that corresponds to a
--   <a>RowColumn</a> position
rowColumnCodeUnits :: RowColumn -> Rope -> Int

-- | Get the <a>RowColumn</a> position that corresponds to a code unit
--   index in the rope
codeUnitsRowColumn :: Int -> Rope -> RowColumn

-- | Split the rope immediately after the i:th newline
splitAtLine :: Int -> Rope -> (Rope, Rope)

-- | <pre>
--   span f r = (takeWhile f r, dropWhile f r)
--   </pre>
span :: (Char -> Bool) -> Rope -> (Rope, Rope)

-- | <pre>
--   break f = span (not . f)
--   </pre>
break :: (Char -> Bool) -> Rope -> (Rope, Rope)

-- | <pre>
--   takeWhile f = fst . span f
--   </pre>
takeWhile :: (Char -> Bool) -> Rope -> Rope

-- | <pre>
--   dropWhile f = snd . span f
--   </pre>
dropWhile :: (Char -> Bool) -> Rope -> Rope

-- | Fold left
foldl :: (a -> Char -> a) -> a -> Rope -> a

-- | A strict version of <a>foldl</a>
foldl' :: (a -> Char -> a) -> a -> Rope -> a

-- | Fold right
foldr :: (Char -> a -> a) -> a -> Rope -> a

-- | Do any characters in the rope satisfy the predicate?
any :: (Char -> Bool) -> Rope -> Bool

-- | Do all characters in the rope satisfy the predicate?
all :: (Char -> Bool) -> Rope -> Bool
