-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell library for the Microsoft Language Server Protocol
--   
--   An implementation of the types, and basic message server to allow
--   language implementors to support the Language Server Protocol for
--   their specific language.
--   
--   An example of this is for Haskell via the Haskell IDE Engine, at
--   <a>https://github.com/haskell/haskell-ide-engine</a>
@package lsp
@version 1.1.1.0

module Language.LSP.Diagnostics
type DiagnosticStore = HashMap NormalizedUri StoreItem
type DiagnosticsBySource = Map (Maybe DiagnosticSource) (SortedList Diagnostic)
data StoreItem
StoreItem :: TextDocumentVersion -> DiagnosticsBySource -> StoreItem
partitionBySource :: [Diagnostic] -> DiagnosticsBySource
flushBySource :: DiagnosticStore -> Maybe DiagnosticSource -> DiagnosticStore
updateDiagnostics :: DiagnosticStore -> NormalizedUri -> TextDocumentVersion -> DiagnosticsBySource -> DiagnosticStore
getDiagnosticParamsFor :: Int -> DiagnosticStore -> NormalizedUri -> Maybe PublishDiagnosticsParams
instance GHC.Classes.Eq Language.LSP.Diagnostics.StoreItem
instance GHC.Show.Show Language.LSP.Diagnostics.StoreItem

module Language.LSP.Server

-- | Convenience function for 'runServerWithHandles stdin stdout'.
runServer :: ServerDefinition config -> IO Int

-- | Starts listening and sending requests and responses using the
--   specified I/O.
runServerWith :: IO ByteString -> (ByteString -> IO ()) -> ServerDefinition config -> IO Int

-- | Starts a language server over the specified handles. This function
--   will return once the <tt>exit</tt> notification is received.
runServerWithHandles :: Handle -> Handle -> ServerDefinition config -> IO Int
data VFSData
VFSData :: !VFS -> !Map FilePath FilePath -> VFSData
[vfsData] :: VFSData -> !VFS
[reverseMap] :: VFSData -> !Map FilePath FilePath

-- | Contains all the callbacks to use for initialized the language server.
--   it is parameterized over a config type variable representing the type
--   for the specific configuration data the language server needs to use.
data ServerDefinition config
ServerDefinition :: (Value -> m (Either Text config)) -> (LanguageContextEnv config -> Message Initialize -> IO (Either ResponseError a)) -> Handlers m -> (a -> m <~> IO) -> Options -> ServerDefinition config

-- | <tt>onConfigurationChange newConfig</tt> is called whenever the
--   clients sends a message with a changed client configuration. This
--   callback should return either the parsed configuration data or an
--   error indicating what went wrong. The parsed configuration object will
--   be stored internally and can be accessed via <tt>config</tt>.
[onConfigurationChange] :: ServerDefinition config -> Value -> m (Either Text config)

-- | Called *after* receiving the <tt>initialize</tt> request and *before*
--   returning the response. This callback will be invoked to offer the
--   language server implementation the chance to create any processes or
--   start new threads that may be necesary for the server lifecycle. It
--   can also return an error in the initialization if necessary.
[doInitialize] :: ServerDefinition config -> LanguageContextEnv config -> Message Initialize -> IO (Either ResponseError a)

-- | Handlers for any methods you want to statically support. The handlers
--   here cannot be unregistered during the server's lifetime and will be
--   regsitered statically in the initialize request.
[staticHandlers] :: ServerDefinition config -> Handlers m

-- | How to run the handlers in your own monad of choice, <tt>m</tt>. It is
--   passed the result of <a>doInitialize</a>, so typically you will want
--   to thread along the <a>LanguageContextEnv</a> as well as any other
--   state you need to run your monad. <tt>m</tt> should most likely be
--   built on top of <a>LspT</a>.
--   
--   <pre>
--   ServerDefinition { ...
--   , doInitialize = env _req -&gt; pure $ Right env
--   , interpretHandler = env -&gt; Iso 
--      (runLspT env) -- how to convert from IO ~&gt; m
--      liftIO        -- how to convert from m ~&gt; IO
--   }
--   </pre>
[interpretHandler] :: ServerDefinition config -> a -> m <~> IO

-- | Configurable options for the server's capabilities.
[options] :: ServerDefinition config -> Options

-- | A mapping from methods to the static <a>Handler</a>s that should be
--   used to handle responses when they come in from the client. To build
--   up a <a>Handlers</a>, you should <a>mconcat</a> a list of
--   <a>notificationHandler</a> and <a>requestHandler</a>s:
--   
--   <pre>
--   mconcat [
--     notificationHandler SInitialized $ notif -&gt; pure ()
--   , requestHandler STextDocumentHover $ req responder -&gt; pure ()
--   ]
--   </pre>
data Handlers m
Handlers :: DMap SMethod (ClientMessageHandler m Request) -> DMap SMethod (ClientMessageHandler m Notification) -> Handlers m
[reqHandlers] :: Handlers m -> DMap SMethod (ClientMessageHandler m Request)
[notHandlers] :: Handlers m -> DMap SMethod (ClientMessageHandler m Notification)

-- | The type of a handler that handles requests and notifications coming
--   in from the server or client
type family Handler (f :: Type -> Type) (m :: Method from t) = (result :: Type) | result -> f t m
transmuteHandlers :: (m <~> n) -> Handlers m -> Handlers n
mapHandlers :: (forall (a :: Method FromClient Request). Handler m a -> Handler n a) -> (forall (a :: Method FromClient Notification). Handler m a -> Handler n a) -> Handlers m -> Handlers n
notificationHandler :: forall (m :: Method FromClient Notification) f. SMethod m -> Handler f m -> Handlers f
requestHandler :: forall (m :: Method FromClient Request) f. SMethod m -> Handler f m -> Handlers f

-- | Wrapper to restrict <a>Handler</a>s to <a>FromClient</a>
--   <a>Method</a>s
newtype ClientMessageHandler f (t :: MethodType) (m :: Method FromClient t)
ClientMessageHandler :: Handler f m -> ClientMessageHandler f (t :: MethodType) (m :: Method FromClient t)

-- | Language Server Protocol options that the server may configure. If you
--   set handlers for some requests, you may need to set some of these
--   options.
data Options
Options :: Maybe TextDocumentSyncOptions -> Maybe [Char] -> Maybe [Char] -> Maybe [Char] -> Maybe [Char] -> Maybe [CodeActionKind] -> Maybe (NonEmpty Char) -> Maybe [Text] -> Maybe ServerInfo -> Options
[textDocumentSync] :: Options -> Maybe TextDocumentSyncOptions

-- | The characters that trigger completion automatically.
[completionTriggerCharacters] :: Options -> Maybe [Char]

-- | The list of all possible characters that commit a completion. This
--   field can be used if clients don't support individual commmit
--   characters per completion item. See
--   <a>$sel:_commitCharactersSupport:CompletionItemClientCapabilities</a>.
[completionAllCommitCharacters] :: Options -> Maybe [Char]

-- | The characters that trigger signature help automatically.
[signatureHelpTriggerCharacters] :: Options -> Maybe [Char]

-- | List of characters that re-trigger signature help. These trigger
--   characters are only active when signature help is already showing. All
--   trigger characters are also counted as re-trigger characters.
[signatureHelpRetriggerCharacters] :: Options -> Maybe [Char]

-- | CodeActionKinds that this server may return. The list of kinds may be
--   generic, such as <a>Refactor</a>, or the server may list out every
--   specific kind they provide.
[codeActionKinds] :: Options -> Maybe [CodeActionKind]

-- | The list of characters that triggers on type formatting. If you set
--   <tt>documentOnTypeFormattingHandler</tt>, you **must** set this. The
--   first character is mandatory, so a <a>NonEmpty</a> should be passed.
[documentOnTypeFormattingTriggerCharacters] :: Options -> Maybe (NonEmpty Char)

-- | The commands to be executed on the server. If you set
--   <tt>executeCommandHandler</tt>, you **must** set this.
[executeCommandCommands] :: Options -> Maybe [Text]

-- | Information about the server that can be advertised to the client.
[serverInfo] :: Options -> Maybe ServerInfo
defaultOptions :: Options
newtype LspT config m a
LspT :: ReaderT (LanguageContextEnv config) m a -> LspT config m a
[unLspT] :: LspT config m a -> ReaderT (LanguageContextEnv config) m a
type LspM config = LspT config IO
class MonadUnliftIO m => MonadLsp config m | m -> config
getLspEnv :: MonadLsp config m => m (LanguageContextEnv config)
runLspT :: LanguageContextEnv config -> LspT config m a -> m a
data LanguageContextEnv config
LanguageContextEnv :: !Handlers IO -> !Value -> IO (Either Text config) -> !FromServerMessage -> IO () -> !TVar (LanguageContextState config) -> !ClientCapabilities -> !Maybe FilePath -> LanguageContextEnv config
[resHandlers] :: LanguageContextEnv config -> !Handlers IO
[resParseConfig] :: LanguageContextEnv config -> !Value -> IO (Either Text config)
[resSendMessage] :: LanguageContextEnv config -> !FromServerMessage -> IO ()
[resState] :: LanguageContextEnv config -> !TVar (LanguageContextState config)
[resClientCapabilities] :: LanguageContextEnv config -> !ClientCapabilities
[resRootPath] :: LanguageContextEnv config -> !Maybe FilePath

-- | How to convert two isomorphic data structures between each other.
data m <~> n
Iso :: (forall a. m a -> n a) -> (forall a. n a -> m a) -> (<~>) m n
[forward] :: (<~>) m n -> forall a. m a -> n a
[backward] :: (<~>) m n -> forall a. n a -> m a
getClientCapabilities :: MonadLsp config m => m ClientCapabilities

-- | The current configuration from the client as set via the
--   <tt>initialize</tt> and <tt>workspace/didChangeConfiguration</tt>
--   requests.
getConfig :: MonadLsp config m => m (Maybe config)
getRootPath :: MonadLsp config m => m (Maybe FilePath)

-- | The current workspace folders, if the client supports workspace
--   folders.
getWorkspaceFolders :: MonadLsp config m => m (Maybe [WorkspaceFolder])
sendRequest :: forall (m :: Method FromServer Request) f config. MonadLsp config f => SServerMethod m -> MessageParams m -> (Either ResponseError (ResponseResult m) -> f ()) -> f (LspId m)
sendNotification :: forall (m :: Method FromServer Notification) f config. MonadLsp config f => SServerMethod m -> MessageParams m -> f ()

-- | Return the <a>VirtualFile</a> associated with a given
--   <a>NormalizedUri</a>, if there is one.
getVirtualFile :: MonadLsp config m => NormalizedUri -> m (Maybe VirtualFile)
getVirtualFiles :: MonadLsp config m => m VFS

-- | Dump the current text for a given VFS file to a temporary file, and
--   return the path to the file.
persistVirtualFile :: MonadLsp config m => NormalizedUri -> m (Maybe FilePath)

-- | Given a text document identifier, annotate it with the latest version.
getVersionedTextDoc :: MonadLsp config m => TextDocumentIdentifier -> m VersionedTextDocumentIdentifier

-- | If the contents of a VFS has been dumped to a temporary file, map the
--   temporary file name back to the original one.
reverseFileMap :: MonadLsp config m => m (FilePath -> FilePath)

-- | Aggregate all diagnostics pertaining to a particular version of a
--   document, by source, and sends a
--   <tt>textDocument/publishDiagnostics</tt> notification with the total
--   (limited by the first parameter) whenever it is updated.
publishDiagnostics :: MonadLsp config m => Int -> NormalizedUri -> TextDocumentVersion -> DiagnosticsBySource -> m ()

-- | Remove all diagnostics from a particular source, and send the updates
--   to the client.
flushDiagnosticsBySource :: MonadLsp config m => Int -> Maybe DiagnosticSource -> m ()

-- | Wrapper for reporting progress to the client during a long running
--   task. <a>withProgress</a> <tt>title cancellable f</tt> starts a new
--   progress reporting session, and finishes it once f is completed. f is
--   provided with an update function that allows it to report on the
--   progress during the session. If <tt>cancellable</tt> is
--   <a>Cancellable</a>, <tt>f</tt> will be thrown a
--   <a>ProgressCancelledException</a> if the user cancels the action in
--   progress.
withProgress :: MonadLsp c m => Text -> ProgressCancellable -> ((ProgressAmount -> m ()) -> m a) -> m a

-- | Same as <a>withProgress</a>, but for processes that do not report the
--   precentage complete.
withIndefiniteProgress :: MonadLsp c m => Text -> ProgressCancellable -> m a -> m a

-- | A package indicating the perecentage of progress complete and a an
--   optional message to go with it during a <a>withProgress</a>
data ProgressAmount
ProgressAmount :: Maybe Double -> Maybe Text -> ProgressAmount

-- | Whether or not the user should be able to cancel a
--   <a>withProgress</a>/<a>withIndefiniteProgress</a> session
data ProgressCancellable
Cancellable :: ProgressCancellable
NotCancellable :: ProgressCancellable

-- | Thrown if the user cancels a <a>Cancellable</a>
--   <a>withProgress</a><i><a>withIndefiniteProgress</a></i> session
data ProgressCancelledException

-- | Sends a <tt>client/registerCapability</tt> request and dynamically
--   registers a <a>Method</a> with a <a>Handler</a>. Returns
--   <a>Nothing</a> if the client does not support dynamic registration for
--   the specified method, otherwise a <a>RegistrationToken</a> which can
--   be used to unregister it later.
registerCapability :: forall f t (m :: Method FromClient t) config. MonadLsp config f => SClientMethod m -> RegistrationOptions m -> Handler f m -> f (Maybe (RegistrationToken m))

-- | Sends a <tt>client/unregisterCapability</tt> request and removes the
--   handler for that associated registration.
unregisterCapability :: MonadLsp config f => RegistrationToken m -> f ()
data RegistrationToken (m :: Method FromClient t)
setupLogger :: Maybe FilePath -> [String] -> Priority -> IO ()

-- | The changes in a workspace edit should be applied from the end of the
--   file toward the start. Sort them into this order.
reverseSortEdit :: WorkspaceEdit -> WorkspaceEdit
