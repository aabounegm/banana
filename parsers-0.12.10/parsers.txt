-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing combinators
--   
--   This library provides convenient combinators for working with and
--   building parsing combinator libraries.
--   
--   Given a few simple instances, e.g. for the class
--   <a>Text.Parser.Combinators.Parsing</a> in
--   <a>Text.Parser.Combinators.Parsing</a> you get access to a large
--   number of canned definitions. Instances exist for the parsers provided
--   by <tt>parsec</tt>, <tt>attoparsec</tt> and baseâ€™s <a>Text.Read</a>.
@package parsers
@version 0.12.10


-- | Alternative parser combinators
module Text.Parser.Combinators

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: Alternative m => [m a] -> m a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative m => a -> m a -> m a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | <tt>skipOptional p</tt> tries to apply parser <tt>p</tt>. It will
--   parse <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>. (Plays the role
--   of parsec's optional, which conflicts with Applicative's optional)
skipOptional :: Alternative m => m a -> m ()

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: Applicative m => m bra -> m ket -> m a -> m a

-- | <tt>p `surroundedBy` f</tt> is <tt>p</tt> surrounded by <tt>f</tt>.
--   Shortcut for <tt>between f f p</tt>. As in <tt>between</tt>, returns
--   the value returned by <tt>p</tt>.
surroundedBy :: Applicative m => m a -> m sur -> m a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt>sepByNonEmpty p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a non-empty list of
--   values returned by <tt>p</tt>.
sepByNonEmpty :: Alternative m => m a -> m sep -> m (NonEmpty a)

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt>sepEndByNonEmpty p sep</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns
--   a non-empty list of values returned by <tt>p</tt>.
sepEndByNonEmpty :: Alternative m => m a -> m sep -> m (NonEmpty a)

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: Alternative m => m a -> m sep -> m [a]

-- | <tt>endByNonEmpty p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a non-empty
--   list of values returned by <tt>p</tt>.
endByNonEmpty :: Alternative m => m a -> m sep -> m (NonEmpty a)

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: Alternative m => m a -> m sep -> m [a]

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Applicative m => Int -> m a -> m [a]

-- | <tt>chainl p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: Alternative m => m a -> m (a -> a -> a) -> a -> m a

-- | <tt>chainr p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: Alternative m => m a -> m (a -> a -> a) -> a -> m a

-- | <tt>chainl1 p op x</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. . This parser can
--   for example be used to eliminate left recursion which typically occurs
--   in expression grammars.
--   
--   <pre>
--   expr   = term   `chainl1` addop
--   term   = factor `chainl1` mulop
--   factor = parens expr &lt;|&gt; integer
--   
--   mulop  = (*) &lt;$ symbol "*"
--        &lt;|&gt; div &lt;$ symbol "/"
--   
--   addop  = (+) &lt;$ symbol "+"
--        &lt;|&gt; (-) &lt;$ symbol "-"
--   </pre>
chainl1 :: Alternative m => m a -> m (a -> a -> a) -> m a

-- | <tt>chainr1 p op x</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>.
chainr1 :: Alternative m => m a -> m (a -> a -> a) -> m a

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: Alternative m => m a -> m end -> m [a]

-- | Additional functionality needed to describe parsers independent of
--   input type.
class Alternative m => Parsing m

-- | Take a parser that may consume input, and on failure, go back to where
--   we started and fail as if we didn't consume input.
try :: Parsing m => m a -> m a

-- | Give a parser a name
(<?>) :: Parsing m => m a -> String -> m a

-- | A version of many that discards its input. Specialized because it can
--   often be implemented more cheaply.
skipMany :: Parsing m => m a -> m ()

-- | <tt>skipSome p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result. (aka skipMany1 in parsec)
skipSome :: Parsing m => m a -> m ()

-- | Used to emit an error on an unexpected token
unexpected :: Parsing m => String -> m a

-- | Used to emit an error on an unexpected token
unexpected :: (Parsing m, MonadTrans t, Monad n, Parsing n, m ~ t n) => String -> m a

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyChar &lt;?&gt; "end of input"
--   </pre>
eof :: Parsing m => m ()

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyChar &lt;?&gt; "end of input"
--   </pre>
eof :: (Parsing m, MonadTrans t, Monad n, Parsing n, m ~ t n) => m ()

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try $ string "let" &lt;* notFollowedBy alphaNum
--   </pre>
notFollowedBy :: (Parsing m, Show a) => m a -> m ()
infixr 0 <?>
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.State.Strict.StateT s m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.Reader.ReaderT e m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Text.Parser.Combinators.Parsing m, GHC.Base.Monad m) => Text.Parser.Combinators.Parsing (Control.Monad.Trans.Identity.IdentityT m)
instance (Text.Parsec.Prim.Stream s m t, GHC.Show.Show t) => Text.Parser.Combinators.Parsing (Text.Parsec.Prim.ParsecT s u m)
instance Data.Attoparsec.Internal.Types.Chunk t => Text.Parser.Combinators.Parsing (Data.Attoparsec.Internal.Types.Parser t)
instance Text.Parser.Combinators.Parsing Data.Binary.Get.Internal.Get
instance Text.Parser.Combinators.Parsing Text.ParserCombinators.ReadP.ReadP


-- | Parsers for character streams
module Text.Parser.Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: CharParsing m => [Char] -> m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character is <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: CharParsing m => [Char] -> m Char

-- | <tt>oneOfSet cs</tt> succeeds if the current character is in the
--   supplied set of characters <tt>cs</tt>. Returns the parsed character.
--   See also <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOfSet :: CharParsing m => CharSet -> m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character is <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOfSet :: CharParsing m => CharSet -> m Char

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: CharParsing m => m ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: CharParsing m => m Char

-- | Parses a newline character ('\n'). Returns a newline character.
newline :: CharParsing m => m Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: CharParsing m => m Char

-- | Parses an upper case letter. Returns the parsed character.
upper :: CharParsing m => m Char

-- | Parses a lower case character. Returns the parsed character.
lower :: CharParsing m => m Char

-- | Parses a letter or digit. Returns the parsed character.
alphaNum :: CharParsing m => m Char

-- | Parses a letter (an upper case or lower case character). Returns the
--   parsed character.
letter :: CharParsing m => m Char

-- | Parses a digit. Returns the parsed character.
digit :: CharParsing m => m Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: CharParsing m => m Char

-- | Parses an octal digit (a character between '0' and '7'). Returns the
--   parsed character.
octDigit :: CharParsing m => m Char
satisfyRange :: CharParsing m => Char -> Char -> m Char

-- | Additional functionality needed to parse character streams.
class Parsing m => CharParsing m

-- | Parse a single character of the input, with UTF-8 decoding
satisfy :: CharParsing m => (Char -> Bool) -> m Char

-- | Parse a single character of the input, with UTF-8 decoding
satisfy :: (CharParsing m, MonadTrans t, CharParsing n, Monad n, m ~ t n) => (Char -> Bool) -> m Char

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character (i.e. <tt>c</tt>).
--   
--   <i>e.g.</i>
--   
--   <pre>
--   semiColon = <a>char</a> ';'
--   </pre>
char :: CharParsing m => Char -> m Char

-- | <tt>notChar c</tt> parses any single character other than <tt>c</tt>.
--   Returns the parsed character.
notChar :: CharParsing m => Char -> m Char

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: CharParsing m => m Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod    =   string "div"
--               &lt;|&gt; string "mod"
--   </pre>
string :: CharParsing m => String -> m String

-- | <tt>text t</tt> parses a sequence of characters determined by the text
--   <tt>t</tt> Returns the parsed text fragment (i.e. <tt>t</tt>).
--   
--   Using <tt>OverloadedStrings</tt>:
--   
--   <pre>
--   divOrMod    =   text "div"
--               &lt;|&gt; text "mod"
--   </pre>
text :: CharParsing m => Text -> m Text
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m) => Text.Parser.Char.CharParsing (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m) => Text.Parser.Char.CharParsing (Control.Monad.Trans.State.Strict.StateT s m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m) => Text.Parser.Char.CharParsing (Control.Monad.Trans.Reader.ReaderT e m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Char.CharParsing (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Char.CharParsing (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Char.CharParsing (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Char.CharParsing (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Text.Parser.Char.CharParsing m, GHC.Base.MonadPlus m) => Text.Parser.Char.CharParsing (Control.Monad.Trans.Identity.IdentityT m)
instance Text.Parsec.Prim.Stream s m GHC.Types.Char => Text.Parser.Char.CharParsing (Text.Parsec.Prim.ParsecT s u m)
instance Data.Attoparsec.Internal.Types.Chunk t => Text.Parser.Char.CharParsing (Data.Attoparsec.Internal.Types.Parser t)
instance Text.Parser.Char.CharParsing Text.ParserCombinators.ReadP.ReadP


-- | A helper module to parse "expressions". Builds a parser given a table
--   of operators and associativities.
module Text.Parser.Expression

-- | This data type specifies the associativity of operators: left, right
--   or none.
data Assoc
AssocNone :: Assoc
AssocLeft :: Assoc
AssocRight :: Assoc

-- | This data type specifies operators that work on values of type
--   <tt>a</tt>. An operator is either binary infix or unary prefix or
--   postfix. A binary operator has also an associated associativity.
data Operator m a
Infix :: m (a -> a -> a) -> Assoc -> Operator m a
Prefix :: m (a -> a) -> Operator m a
Postfix :: m (a -> a) -> Operator m a

-- | An <tt>OperatorTable m a</tt> is a list of <tt>Operator m a</tt>
--   lists. The list is ordered in descending precedence. All operators in
--   one list have the same precedence (but may have a different
--   associativity).
type OperatorTable m a = [[Operator m a]]

-- | <tt>buildExpressionParser table term</tt> builds an expression parser
--   for terms <tt>term</tt> with operators from <tt>table</tt>, taking the
--   associativity and precedence specified in <tt>table</tt> into account.
--   Prefix and postfix operators of the same precedence can only occur
--   once (i.e. <tt>--2</tt> is not allowed if <tt>-</tt> is prefix
--   negate). Prefix and postfix operators of the same precedence associate
--   to the left (i.e. if <tt>++</tt> is postfix increment, than
--   <tt>-2++</tt> equals <tt>-1</tt>, not <tt>-3</tt>).
--   
--   The <tt>buildExpressionParser</tt> takes care of all the complexity
--   involved in building expression parser. Here is an example of an
--   expression parser that handles prefix signs, postfix increment and
--   basic arithmetic.
--   
--   <pre>
--   import Control.Applicative ((&lt;|&gt;))
--   import Text.Parser.Combinators ((&lt;?&gt;))
--   import Text.Parser.Expression
--   import Text.Parser.Token (TokenParsing, natural, parens, reserve)
--   import Text.Parser.Token.Style (emptyOps)
--   
--   expr   :: (Monad m, TokenParsing m) =&gt; m Integer
--   expr    = buildExpressionParser table term
--           &lt;?&gt; "expression"
--   
--   term   :: (Monad m, TokenParsing m) =&gt; m Integer
--   term    =  parens expr
--           &lt;|&gt; natural
--           &lt;?&gt; "simple expression"
--   
--   table  :: (Monad m, TokenParsing m) =&gt; [[Operator m Integer]]
--   table   = [ [prefix "-" negate, prefix "+" id ]
--             , [postfix "++" (+1)]
--             , [binary "*" (*) AssocLeft, binary "/" (div) AssocLeft ]
--             , [binary "+" (+) AssocLeft, binary "-" (-)   AssocLeft ]
--             ]
--   
--   binary  name fun assoc = Infix (fun &lt;$ reservedOp name) assoc
--   prefix  name fun       = Prefix (fun &lt;$ reservedOp name)
--   postfix name fun       = Postfix (fun &lt;$ reservedOp name)
--   
--   reservedOp name = reserve emptyOps name
--   </pre>
buildExpressionParser :: forall m a. (Parsing m, Applicative m) => OperatorTable m a -> m a -> m a
instance Data.Data.Data Text.Parser.Expression.Assoc
instance GHC.Enum.Bounded Text.Parser.Expression.Assoc
instance GHC.Enum.Enum Text.Parser.Expression.Assoc
instance GHC.Ix.Ix Text.Parser.Expression.Assoc
instance GHC.Read.Read Text.Parser.Expression.Assoc
instance GHC.Show.Show Text.Parser.Expression.Assoc
instance GHC.Classes.Ord Text.Parser.Expression.Assoc
instance GHC.Classes.Eq Text.Parser.Expression.Assoc


-- | Parsers that can <a>lookAhead</a>.
module Text.Parser.LookAhead

-- | Additional functionality needed to describe parsers independent of
--   input type.
class Parsing m => LookAheadParsing m

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
lookAhead :: LookAheadParsing m => m a -> m a
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.State.Strict.StateT s m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.Reader.ReaderT e m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Text.Parser.LookAhead.LookAheadParsing m, GHC.Base.Monad m) => Text.Parser.LookAhead.LookAheadParsing (Control.Monad.Trans.Identity.IdentityT m)
instance (Text.Parsec.Prim.Stream s m t, GHC.Show.Show t) => Text.Parser.LookAhead.LookAheadParsing (Text.Parsec.Prim.ParsecT s u m)
instance Data.Attoparsec.Internal.Types.Chunk i => Text.Parser.LookAhead.LookAheadParsing (Data.Attoparsec.Internal.Types.Parser i)
instance Text.Parser.LookAhead.LookAheadParsing Data.Binary.Get.Internal.Get
instance Text.Parser.LookAhead.LookAheadParsing Text.ParserCombinators.ReadP.ReadP


-- | This module implements permutation parsers. The algorithm is described
--   in:
--   
--   <i>Parsing Permutation Phrases,</i> by Arthur Baars, Andres Loh and
--   Doaitse Swierstra. Published as a functional pearl at the Haskell
--   Workshop 2001.
module Text.Parser.Permutation

-- | The type <tt>Permutation m a</tt> denotes a permutation parser that,
--   when converted by the <a>permute</a> function, parses using the base
--   parsing monad <tt>m</tt> and returns a value of type <tt>a</tt> on
--   success.
--   
--   Normally, a permutation parser is first build with special operators
--   like (<a>&lt;||&gt;</a>) and than transformed into a normal parser
--   using <a>permute</a>.
data Permutation m a

-- | The parser <tt>permute perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test  = permute (tuple &lt;$?&gt; ("",some (char 'a'))
--                          &lt;||&gt; char 'b'
--                          &lt;|?&gt; ('_',char 'c'))
--         where
--           tuple a b c  = (a,b,c)
--   </pre>
permute :: forall m a. Alternative m => Permutation m a -> m a

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: Functor m => Permutation m (a -> b) -> m a -> Permutation m b
infixl 1 <||>

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: Functor m => (a -> b) -> m a -> Permutation m b
infixl 2 <$$>

-- | The expression <tt>perm &lt;|?&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: Functor m => Permutation m (a -> b) -> (a, m a) -> Permutation m b
infixl 1 <|?>

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: Functor m => (a -> b) -> (a, m a) -> Permutation m b
infixl 2 <$?>
instance GHC.Base.Functor m => GHC.Base.Functor (Text.Parser.Permutation.Permutation m)
instance GHC.Base.Functor m => GHC.Base.Functor (Text.Parser.Permutation.Branch m)


-- | Highlighting isn't strictly a parsing concern, but it makes more sense
--   to annotate a parser with highlighting information than to require
--   someone to completely reimplement all of the combinators to add this
--   functionality later when they need it.
module Text.Parser.Token.Highlight

-- | Tags used by the <a>TokenParsing</a> <a>highlight</a> combinator.
data Highlight
EscapeCode :: Highlight
Number :: Highlight
Comment :: Highlight
CharLiteral :: Highlight
StringLiteral :: Highlight
Constant :: Highlight
Statement :: Highlight
Special :: Highlight
Symbol :: Highlight
Identifier :: Highlight
ReservedIdentifier :: Highlight
Operator :: Highlight
ReservedOperator :: Highlight
Constructor :: Highlight
ReservedConstructor :: Highlight
ConstructorOperator :: Highlight
ReservedConstructorOperator :: Highlight
BadInput :: Highlight
Unbound :: Highlight
Layout :: Highlight
MatchedSymbols :: Highlight
LiterateComment :: Highlight
LiterateSyntax :: Highlight
instance GHC.Enum.Bounded Text.Parser.Token.Highlight.Highlight
instance GHC.Enum.Enum Text.Parser.Token.Highlight.Highlight
instance GHC.Read.Read Text.Parser.Token.Highlight.Highlight
instance GHC.Show.Show Text.Parser.Token.Highlight.Highlight
instance GHC.Classes.Ord Text.Parser.Token.Highlight.Highlight
instance GHC.Classes.Eq Text.Parser.Token.Highlight.Highlight


-- | Parsers that comprehend whitespace and identifier styles
--   
--   <pre>
--   idStyle    = haskellIdents { styleReserved = ... }
--   identifier = ident idStyle
--   reserved   = reserve idStyle
--   </pre>
module Text.Parser.Token

-- | Skip zero or more bytes worth of white space. More complex parsers are
--   free to consider comments as white space.
whiteSpace :: TokenParsing m => m ()

-- | This token parser parses a single literal character. Returns the
--   literal character value. This parsers deals correctly with escape
--   sequences. The literal character is parsed according to the grammar
--   rules defined in the Haskell report (which matches most programming
--   languages quite closely).
charLiteral :: forall m. TokenParsing m => m Char

-- | This token parser parses a literal string. Returns the literal string
--   value. This parsers deals correctly with escape sequences and gaps.
--   The literal string is parsed according to the grammar rules defined in
--   the Haskell report (which matches most programming languages quite
--   closely).
stringLiteral :: forall m s. (TokenParsing m, IsString s) => m s

-- | This token parser behaves as <a>stringLiteral</a>, but for
--   single-quoted strings.
stringLiteral' :: forall m s. (TokenParsing m, IsString s) => m s

-- | This token parser parses a natural number (a non-negative whole
--   number). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
natural :: TokenParsing m => m Integer

-- | This token parser parses an integer (a whole number). This parser is
--   like <a>natural</a> except that it can be prefixed with sign (i.e. '-'
--   or '+'). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
integer :: forall m. TokenParsing m => m Integer

-- | This token parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
double :: TokenParsing m => m Double

-- | This token parser parses either <a>natural</a> or a <tt>float</tt>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
naturalOrDouble :: TokenParsing m => m (Either Integer Double)

-- | This token parser is like <a>naturalOrDouble</a>, but handles leading
--   <tt>-</tt> or <tt>+</tt>.
integerOrDouble :: TokenParsing m => m (Either Integer Double)

-- | This token parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
scientific :: TokenParsing m => m Scientific

-- | This token parser parses either <a>natural</a> or a <a>scientific</a>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
naturalOrScientific :: TokenParsing m => m (Either Integer Scientific)

-- | This token parser is like <a>naturalOrScientific</a>, but handles
--   leading <tt>-</tt> or <tt>+</tt>.
integerOrScientific :: forall m. TokenParsing m => m (Either Integer Scientific)

-- | Token parser <tt>symbol s</tt> parses <a>string</a> <tt>s</tt> and
--   skips trailing white space.
symbol :: TokenParsing m => String -> m String

-- | Token parser <tt>textSymbol t</tt> parses <a>text</a> <tt>s</tt> and
--   skips trailing white space.
textSymbol :: TokenParsing m => Text -> m Text

-- | Token parser <tt>symbolic s</tt> parses <a>char</a> <tt>s</tt> and
--   skips trailing white space.
symbolic :: TokenParsing m => Char -> m Char

-- | Token parser <tt>parens p</tt> parses <tt>p</tt> enclosed in
--   parenthesis, returning the value of <tt>p</tt>.
parens :: TokenParsing m => m a -> m a

-- | Token parser <tt>braces p</tt> parses <tt>p</tt> enclosed in braces
--   ('{' and '}'), returning the value of <tt>p</tt>.
braces :: TokenParsing m => m a -> m a

-- | Token parser <tt>angles p</tt> parses <tt>p</tt> enclosed in angle
--   brackets ('&lt;' and '&gt;'), returning the value of <tt>p</tt>.
angles :: TokenParsing m => m a -> m a

-- | Token parser <tt>brackets p</tt> parses <tt>p</tt> enclosed in
--   brackets ('[' and ']'), returning the value of <tt>p</tt>.
brackets :: TokenParsing m => m a -> m a

-- | Token parser <tt>comma</tt> parses the character ',' and skips any
--   trailing white space. Returns the string ",".
comma :: TokenParsing m => m Char

-- | Token parser <tt>colon</tt> parses the character ':' and skips any
--   trailing white space. Returns the string ":".
colon :: TokenParsing m => m Char

-- | Token parser <tt>dot</tt> parses the character '.' and skips any
--   trailing white space. Returns the string ".".
dot :: TokenParsing m => m Char

-- | Token parser <tt>semiSep p</tt> parses <i>zero</i> or more occurrences
--   of <tt>p</tt> separated by <a>semi</a>. Returns a list of values
--   returned by <tt>p</tt>.
semiSep :: TokenParsing m => m a -> m [a]

-- | Token parser <tt>semiSep1 p</tt> parses <i>one</i> or more occurrences
--   of <tt>p</tt> separated by <a>semi</a>. Returns a list of values
--   returned by <tt>p</tt>.
semiSep1 :: TokenParsing m => m a -> m [a]

-- | Token parser <tt>commaSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
commaSep :: TokenParsing m => m a -> m [a]

-- | Token parser <tt>commaSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
commaSep1 :: TokenParsing m => m a -> m [a]

-- | Additional functionality that is needed to tokenize input while
--   ignoring whitespace.
class CharParsing m => TokenParsing m

-- | Usually, someSpace consists of <i>one</i> or more occurrences of a
--   <a>space</a>. Some parsers may choose to recognize line comments or
--   block (multi line) comments as white space as well.
someSpace :: TokenParsing m => m ()

-- | Called when we enter a nested pair of symbols. Overloadable to enable
--   disabling layout
nesting :: TokenParsing m => m a -> m a

-- | The token parser |semi| parses the character ';' and skips any
--   trailing white space. Returns the character ';'. Overloadable to
--   permit automatic semicolon insertion or Haskell-style layout.
semi :: TokenParsing m => m Char

-- | Tag a region of parsed text with a bit of semantic information. Most
--   parsers won't use this, but it is indispensible for highlighters.
highlight :: TokenParsing m => Highlight -> m a -> m a

-- | <tt>token p</tt> first applies parser <tt>p</tt> and then the
--   <a>whiteSpace</a> parser, returning the value of <tt>p</tt>. Every
--   lexical token (token) is defined using <tt>token</tt>, this way every
--   parse starts at a point without white space. Parsers that use
--   <tt>token</tt> are called <i>token</i> parsers in this document.
--   
--   The only point where the <a>whiteSpace</a> parser should be called
--   explicitly is the start of the main parser in order to skip any
--   leading white space.
--   
--   Alternatively, one might define <a>token</a> as first parsing
--   <a>whiteSpace</a> and then parser <tt>p</tt>. By parsing whiteSpace
--   first, the parser is able to return before parsing additional
--   whiteSpace, improving laziness.
--   
--   <pre>
--   mainParser  = sum &lt;$ whiteSpace &lt;*&gt; many (token digit) &lt;* eof
--   </pre>
token :: TokenParsing m => m a -> m a

-- | This is a parser transformer you can use to disable the automatic
--   trailing space consumption of a Token parser.
newtype Unspaced m a
Unspaced :: m a -> Unspaced m a
[runUnspaced] :: Unspaced m a -> m a

-- | This is a parser transformer you can use to disable the automatic
--   trailing newline (but not whitespace-in-general) consumption of a
--   Token parser.
newtype Unlined m a
Unlined :: m a -> Unlined m a
[runUnlined] :: Unlined m a -> m a

-- | This is a parser transformer you can use to disable syntax
--   highlighting over a range of text you are parsing.
newtype Unhighlighted m a
Unhighlighted :: m a -> Unhighlighted m a
[runUnhighlighted] :: Unhighlighted m a -> m a

-- | Parses a non-negative whole number in the decimal system. Returns the
--   value of the number.
--   
--   This parser does NOT swallow trailing whitespace
decimal :: TokenParsing m => m Integer

-- | Parses a non-negative whole number in the hexadecimal system. The
--   number should be prefixed with "x" or "X". Returns the value of the
--   number.
--   
--   This parser does NOT swallow trailing whitespace
hexadecimal :: TokenParsing m => m Integer

-- | Parses a non-negative whole number in the octal system. The number
--   should be prefixed with "o" or "O". Returns the value of the number.
--   
--   This parser does NOT swallow trailing whitespace
octal :: TokenParsing m => m Integer

-- | This parser parses a character literal without the surrounding
--   quotation marks.
--   
--   This parser does NOT swallow trailing whitespace
characterChar :: TokenParsing m => m Char

-- | This parser parses an integer (a whole number). This parser is like
--   <a>natural</a> except that it can be prefixed with sign (i.e. '-' or
--   '+'). Returns the value of the number. The number can be specified in
--   <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
--   
--   This parser does NOT swallow trailing whitespace.
--   
--   Also, unlike the <a>integer</a> parser, this parser does not admit
--   spaces between the sign and the number.
integer' :: TokenParsing m => m Integer

-- | Used to describe an input style for constructors, values, operators,
--   etc.
data IdentifierStyle m
IdentifierStyle :: String -> m Char -> m Char -> HashSet String -> Highlight -> Highlight -> IdentifierStyle m
[_styleName] :: IdentifierStyle m -> String
[_styleStart] :: IdentifierStyle m -> m Char
[_styleLetter] :: IdentifierStyle m -> m Char
[_styleReserved] :: IdentifierStyle m -> HashSet String
[_styleHighlight] :: IdentifierStyle m -> Highlight
[_styleReservedHighlight] :: IdentifierStyle m -> Highlight

-- | Lift an identifier style into a monad transformer
--   
--   Using <tt>over</tt> from the <tt>lens</tt> package:
--   
--   <pre>
--   <a>liftIdentifierStyle</a> = over <a>styleChars</a> <a>lift</a>
--   </pre>
liftIdentifierStyle :: (MonadTrans t, Monad m) => IdentifierStyle m -> IdentifierStyle (t m)

-- | Parse a non-reserved identifier or symbol
ident :: (TokenParsing m, Monad m, IsString s) => IdentifierStyle m -> m s

-- | parse a reserved operator or identifier using a given style
reserve :: (TokenParsing m, Monad m) => IdentifierStyle m -> String -> m ()

-- | parse a reserved operator or identifier using a given style given
--   <a>Text</a>.
reserveText :: (TokenParsing m, Monad m) => IdentifierStyle m -> Text -> m ()

-- | This lens can be used to update the name for this style of identifier.
--   
--   <pre>
--   <a>styleName</a> :: Lens' (<a>IdentifierStyle</a> m) <a>String</a>
--   </pre>
styleName :: Functor f => (String -> f String) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This lens can be used to update the action used to recognize the first
--   letter in an identifier.
--   
--   <pre>
--   <a>styleStart</a> :: Lens' (<a>IdentifierStyle</a> m) (m <a>Char</a>)
--   </pre>
styleStart :: Functor f => (m Char -> f (m Char)) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This lens can be used to update the action used to recognize
--   subsequent letters in an identifier.
--   
--   <pre>
--   <a>styleLetter</a> :: Lens' (<a>IdentifierStyle</a> m) (m <a>Char</a>)
--   </pre>
styleLetter :: Functor f => (m Char -> f (m Char)) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a traversal of both actions in contained in an
--   <a>IdentifierStyle</a>.
--   
--   <pre>
--   <a>styleChars</a> :: Traversal (<a>IdentifierStyle</a> m) (<a>IdentifierStyle</a> n) (m <a>Char</a>) (n <a>Char</a>)
--   </pre>
styleChars :: Applicative f => (m Char -> f (n Char)) -> IdentifierStyle m -> f (IdentifierStyle n)

-- | This is a lens that can be used to modify the reserved identifier set.
--   
--   <pre>
--   <a>styleReserved</a> :: Lens' (<a>IdentifierStyle</a> m) (<a>HashSet</a> <a>String</a>)
--   </pre>
styleReserved :: Functor f => (HashSet String -> f (HashSet String)) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a lens that can be used to modify the highlight used for this
--   identifier set.
--   
--   <pre>
--   <a>styleHighlight</a> :: Lens' (<a>IdentifierStyle</a> m) <a>Highlight</a>
--   </pre>
styleHighlight :: Functor f => (Highlight -> f Highlight) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a lens that can be used to modify the highlight used for
--   reserved identifiers in this identifier set.
--   
--   <pre>
--   <a>styleReservedHighlight</a> :: Lens' (<a>IdentifierStyle</a> m) <a>Highlight</a>
--   </pre>
styleReservedHighlight :: Functor f => (Highlight -> f Highlight) -> IdentifierStyle m -> f (IdentifierStyle m)

-- | This is a traversal that can be used to modify the highlights used for
--   both non-reserved and reserved identifiers in this identifier set.
--   
--   <pre>
--   <a>styleHighlights</a> :: Traversal' (<a>IdentifierStyle</a> m) <a>Highlight</a>
--   </pre>
styleHighlights :: Applicative f => (Highlight -> f Highlight) -> IdentifierStyle m -> f (IdentifierStyle m)
instance Text.Parser.Char.CharParsing m => Text.Parser.Char.CharParsing (Text.Parser.Token.Unhighlighted m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Text.Parser.Token.Unhighlighted m)
instance GHC.Base.Monad m => GHC.Base.Monad (Text.Parser.Token.Unhighlighted m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Text.Parser.Token.Unhighlighted m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Text.Parser.Token.Unhighlighted m)
instance GHC.Base.Functor m => GHC.Base.Functor (Text.Parser.Token.Unhighlighted m)
instance Text.Parser.Char.CharParsing m => Text.Parser.Char.CharParsing (Text.Parser.Token.Unspaced m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Text.Parser.Token.Unspaced m)
instance GHC.Base.Monad m => GHC.Base.Monad (Text.Parser.Token.Unspaced m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Text.Parser.Token.Unspaced m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Text.Parser.Token.Unspaced m)
instance GHC.Base.Functor m => GHC.Base.Functor (Text.Parser.Token.Unspaced m)
instance Text.Parser.Char.CharParsing m => Text.Parser.Char.CharParsing (Text.Parser.Token.Unlined m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Text.Parser.Token.Unlined m)
instance GHC.Base.Monad m => GHC.Base.Monad (Text.Parser.Token.Unlined m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Text.Parser.Token.Unlined m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Text.Parser.Token.Unlined m)
instance GHC.Base.Functor m => GHC.Base.Functor (Text.Parser.Token.Unlined m)
instance Text.Parser.Combinators.Parsing m => Text.Parser.Combinators.Parsing (Text.Parser.Token.Unlined m)
instance Control.Monad.Trans.Class.MonadTrans Text.Parser.Token.Unlined
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Text.Parser.Token.Unlined m)
instance Control.Monad.Reader.Class.MonadReader e m => Control.Monad.Reader.Class.MonadReader e (Text.Parser.Token.Unlined m)
instance Control.Monad.Writer.Class.MonadWriter e m => Control.Monad.Writer.Class.MonadWriter e (Text.Parser.Token.Unlined m)
instance Text.Parser.Token.TokenParsing m => Text.Parser.Token.TokenParsing (Text.Parser.Token.Unlined m)
instance Text.Parser.Combinators.Parsing m => Text.Parser.Combinators.Parsing (Text.Parser.Token.Unspaced m)
instance Control.Monad.Trans.Class.MonadTrans Text.Parser.Token.Unspaced
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Text.Parser.Token.Unspaced m)
instance Control.Monad.Reader.Class.MonadReader e m => Control.Monad.Reader.Class.MonadReader e (Text.Parser.Token.Unspaced m)
instance Control.Monad.Writer.Class.MonadWriter e m => Control.Monad.Writer.Class.MonadWriter e (Text.Parser.Token.Unspaced m)
instance Text.Parser.Token.TokenParsing m => Text.Parser.Token.TokenParsing (Text.Parser.Token.Unspaced m)
instance Text.Parser.Combinators.Parsing m => Text.Parser.Combinators.Parsing (Text.Parser.Token.Unhighlighted m)
instance Control.Monad.Trans.Class.MonadTrans Text.Parser.Token.Unhighlighted
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Text.Parser.Token.Unhighlighted m)
instance Control.Monad.Reader.Class.MonadReader e m => Control.Monad.Reader.Class.MonadReader e (Text.Parser.Token.Unhighlighted m)
instance Control.Monad.Writer.Class.MonadWriter e m => Control.Monad.Writer.Class.MonadWriter e (Text.Parser.Token.Unhighlighted m)
instance Text.Parser.Token.TokenParsing m => Text.Parser.Token.TokenParsing (Text.Parser.Token.Unhighlighted m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.State.Strict.StateT s m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.Reader.ReaderT e m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m, GHC.Base.Monoid w) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Text.Parser.Token.TokenParsing m, GHC.Base.MonadPlus m) => Text.Parser.Token.TokenParsing (Control.Monad.Trans.Identity.IdentityT m)
instance Text.Parsec.Prim.Stream s m GHC.Types.Char => Text.Parser.Token.TokenParsing (Text.Parsec.Prim.ParsecT s u m)
instance Data.Attoparsec.Internal.Types.Chunk t => Text.Parser.Token.TokenParsing (Data.Attoparsec.Internal.Types.Parser t)
instance Text.Parser.Token.TokenParsing Text.ParserCombinators.ReadP.ReadP


-- | A toolbox for specifying comment and identifier styles
--   
--   This must be imported directly as it is not re-exported elsewhere
module Text.Parser.Token.Style

-- | How to deal with comments.
data CommentStyle
CommentStyle :: String -> String -> String -> Bool -> CommentStyle

-- | String that starts a multiline comment
[_commentStart] :: CommentStyle -> String

-- | String that ends a multiline comment
[_commentEnd] :: CommentStyle -> String

-- | String that starts a single line comment
[_commentLine] :: CommentStyle -> String

-- | Can we nest multiline comments?
[_commentNesting] :: CommentStyle -> Bool

-- | This is a lens that can edit the string that starts a multiline
--   comment.
--   
--   <pre>
--   <a>commentStart</a> :: Lens' <a>CommentStyle</a> <a>String</a>
--   </pre>
commentStart :: Functor f => (String -> f String) -> CommentStyle -> f CommentStyle

-- | This is a lens that can edit the string that ends a multiline comment.
--   
--   <pre>
--   <a>commentEnd</a> :: Lens' <a>CommentStyle</a> <a>String</a>
--   </pre>
commentEnd :: Functor f => (String -> f String) -> CommentStyle -> f CommentStyle

-- | This is a lens that can edit the string that starts a single line
--   comment.
--   
--   <pre>
--   <a>commentLine</a> :: Lens' <a>CommentStyle</a> <a>String</a>
--   </pre>
commentLine :: Functor f => (String -> f String) -> CommentStyle -> f CommentStyle

-- | This is a lens that can edit whether we can nest multiline comments.
--   
--   <pre>
--   <a>commentNesting</a> :: Lens' <a>CommentStyle</a> <a>Bool</a>
--   </pre>
commentNesting :: Functor f => (Bool -> f Bool) -> CommentStyle -> f CommentStyle

-- | No comments at all
emptyCommentStyle :: CommentStyle

-- | Use java-style comments
javaCommentStyle :: CommentStyle

-- | Use scala-style comments
scalaCommentStyle :: CommentStyle

-- | Use haskell-style comments
haskellCommentStyle :: CommentStyle

-- | Use this to easily build the definition of whiteSpace for your
--   MonadParser given a comment style and an underlying someWhiteSpace
--   parser
buildSomeSpaceParser :: forall m. CharParsing m => m () -> CommentStyle -> m ()

-- | A simple identifier style based on haskell with no reserve words
emptyIdents :: TokenParsing m => IdentifierStyle m

-- | A simple identifier style based on haskell with the reserved words
--   from Haskell 98 and some common extensions.
haskellIdents :: TokenParsing m => IdentifierStyle m

-- | A simple identifier style based on haskell with only the reserved
--   words from Haskell 98.
haskell98Idents :: TokenParsing m => IdentifierStyle m

-- | A simple operator style based on haskell with no reserved operators
emptyOps :: TokenParsing m => IdentifierStyle m

-- | A simple operator style based on haskell with the operators from
--   Haskell 98.
haskellOps :: TokenParsing m => IdentifierStyle m

-- | A simple operator style based on haskell with the operators from
--   Haskell 98.
haskell98Ops :: TokenParsing m => IdentifierStyle m
instance Data.Data.Data Text.Parser.Token.Style.CommentStyle
instance GHC.Read.Read Text.Parser.Token.Style.CommentStyle
instance GHC.Show.Show Text.Parser.Token.Style.CommentStyle
instance GHC.Classes.Ord Text.Parser.Token.Style.CommentStyle
instance GHC.Classes.Eq Text.Parser.Token.Style.CommentStyle
